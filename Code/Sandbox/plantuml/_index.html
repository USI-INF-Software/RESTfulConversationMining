<section id="title">
    <h3>Software Architecture</h3>
    <h1>Modeling</h1>
    <p>Prof. Cesare Pautasso</p>
    <p><a href="http://www.pautasso.info/">http://www.pautasso.info/</a><br />
        cesare.pautasso@usi.ch</p>
    <asq-welcome join-message=""></asq-welcome>
</section>
<section id="outline" class="">
    <h1>Contents</h1>
    <ul>
        <li>Modeling: Why, What, How</li>
        <li>Views</li>
        <li>Canonical Models: Domain, Design and Code Models</li>
        <li>Domain Modeling: Use Case Scenarios, Feature Models</li>
        <li>C5: Context, Containers, Components, Connectors, Classes</li>
        <li>4+1: Logical, Process, Development, Physical</li>
        <li>Quality of Models</li>
        <li>Model Driven Architecture</li>
    </ul>
</section>
<section id="avc" class="">
    <h2>Capturing the Architecture</h2>
    <p class="credit">Grady Booch</p>
        <ul>
            <li>Every system has an architecture</li>
            <li>Some architectures are manifest and visible, many others are not</li>
            <li>A system's <b>descriptive</b> architecture ultimately resides in its executable code</li>
            <li>Before a system is built, its <b>prescriptive</b> architecture should be made explicit</li>
            <li class="fragment">A system's architecture may be <b>visualized and represented using models</b> that are somehow related to the code (existing or yet to be written)</li>
        </ul>
</section>
<section id="quote" class="big" data-background-image="images/paris-paper-curtains.jpg">
    <h2>One month of coding can save you one hour of architecting</h2>
</section>
<section id="asq-coa" class="centered">
    <h2>Code or Architecture?</h2>
    <asq-exercise>
        <asq-buckets-q class="small" mode="1-10" x-matchable="div[buckets]" y-matchable="div[labels]" attr-for-matched="s-name" matched-attribute="matched" label-container="[labels]" matched-class="label-success">
            <asq-stem>Classify the following:</asq-stem>
            <br>
            <div buckets="" class="small">
                <div s-name="a" class="bucket">Architecture</div>
                <div s-name="ac" class="bucket">Architecture and Code</div>
                <div s-name="c" class="bucket">Code</div>
                <div s-name="d" class="bucket">Don't Know</div>
            </div>
            <div labels="" class="small">
                <div s-name="a" label="" class="label label-primary">Component</div>
                <div s-name="b" label="" class="label label-primary">Connector</div>
                <div s-name="c" label="" class="label label-primary">Class</div>
                <div s-name="d" label="" class="label label-primary">Container</div>
                <div s-name="e" label="" class="label label-primary">Constraint</div>
                <div s-name="f" label="" class="label label-primary">Configuration</div>
                <div s-name="g" label="" class="label label-primary">Call</div>
                <div s-name="h" label="" class="label label-primary">Context</div>
                <div s-name="j" label="" class="label label-primary">Constant</div>
            </div>
            <div style="clear:both; float:none;" />
            </br>
        </asq-buckets-q>
    </asq-exercise>
</section>
<section id="what" class="">
    <h2>What is modeling?</h2>
    <p class="credit">Richard Taylor</p>
    <ul>
        <li>An architectural <b>model</b> is an artifact that captures some or all of the design decisions that comprise a system’s architecture.</li>
        <li class="fragment">Architectural <b>modeling</b> is the reification and documentation of those design decisions.</li>
    </ul>
</section>
<section id="what-ex" class="">
    <h3>Abstraction and Interpretation</h3>
    <img src="images/model.svg" class="svg"/>
    <ul>
        <li>The architecture models only some interesting aspects of a software system.</li>
    </ul>
</section>
<section id="problem" class="">
    <h3>Solving Problems with Models</h3>
    <img src="images/problem.svg" class="svg"/>
    <ul>
        <li>Abstract models help to find solutions to difficult engineering problems.</li>
    </ul>
    <p class="credit">Mary Shaw</p>
</section>
<section id="qm" class="">
    <h3>Question first, Model second</h3>
    <p class="credit">George Fairbanks</p>
    <ul>
        <li>Different models have different purposes</li>
        <li>Know what questions you want the model to answer before you build it</li>
    </ul>
    <p class="fragment quote">All models are wrong; some models are useful.</p>
</section>
<section id="scope" class="">
    <h2>&#x1F50E; Scope of the Model</h2>
    <ol>
        <li>Parts of the software (e.g., as it is deployed on each device)</li>
        <li>Specific use cases (e.g., which API is invoked by some user)</li>
        <li>The whole architecture of the entire software (covering all use cases)</li>
        <li>The style of the software (constrain all possible architectures without describing any of them)</li>
    </ol>
    <p class="fragment quote">Overview first, zoom and filter, then details-on-demand.</p>
</section>
<section id="view-t" class="big pdf-skip" data-background-image="images/a-gehri-berlin.jpg">
    <h1>Views</h1>
</section>
<section id="view" class="">
    <h2>What is a view?</h2>
    <div class="flex row top">
        <ul>
            <li>No single modeling approach can capture the entire complexity of a software architecture</li>
            <li>
                Various parts of the architecture (or views) may have to be modeled with a different:<ul>
                    <li>
                        Notation</li>
                    <li>
                        Level of detail</li>
                    <li>
                        Target Audience</li>
                </ul>
            </li>
        </ul>
        <ul>
            <li class="fragment">A <b>view</b> is a set of design decisions related by common concerns (the viewpoint)
                <img src="images/viewpoint.svg" class="svg"/>
</li>
        </ul>
    </div>
</section>
<section id="asq-view" class="pdf-skip">
    <h3>What could be an example of an architectural view?</h3>
    <asq-exercise>
        <asq-text-input-q label="view/viewpoint example" id="tbq-1">
            <asq-stem />
            <asq-solution hidden />
        </asq-text-input-q>
    </asq-exercise>
    <asq-text-input-q-stats for="tbq-1" show-viewer="all">
    </asq-text-input-q-stats>
</section>
<section id="viewex" class="">
    <h2>How many views?</h2>
    <ul class="twocol">
        <li>System Context</li>
        <li>Functional</li>
        <li>Logical</li>
        <li>Physical</li>
        <li>Deployment</li>
        <li>Development</li>
        <li>Information</li>
        <li>Process</li>
        <li>Concurrency</li>
        <li>Operational</li>
        <li>Security</li>
        <li>Performance and Scalability</li>
        <li>Availability and Reliability</li>
        <li>Evolution</li>
        <li>Teachability<br>("Welcome to the team")</li>
        <li>Regulatory</li>
        <li>Marketing</li>
        <li>Business Impact</li>
    </ul>
    <p class="credit">Rozanski &amp; Woods</p>
</section>
<section id="views" class="centered">
    <h2>Multiple Views</h2>
    <ul>
        <li>There is too much information to model: we need multiple views</li>
    </ul>
    <img src="images/mviews.svg" class="svg"/>
</section>
    <section id="views2" class="centered">
        <h2>View Consistency</h2>
        <ul>
            <li>Views are not always orthogonal and should not become inconsistent</li>
        </ul>
        <img src="images/mviews2.svg" class="svg"/>
</section>
        <section id="canonical" class="">
            <h2>Canonical Models</h2>
            <p class="credit">George Fairbanks</p>
            <img src="images/canonical.svg" class="svg"/>
            <section id="canonical0" class="pdf-skip"></section>
            <section id="domain">
                <h2 class="onlyprint">Domain Model</h2>
                <ul>
                    <li>Refutable truths about the real-world
                    </li>
                    <li>Outside your control
                    </li>
                    <li>Your system will be evaluated against it</li>
                    <li>Architecturally significant requirements</li>
                </ul>
            </section>
            <section id="code" class="">
                <h2 class="onlyprint">Code Model</h2>
                <ul>
                    <li>Complete set of design commitments
                    </li>
                    <li>Represent the executable, ready-to-run "source code"
                    </li>
                </ul>
            </section>
            <section id="design" class="">
                <h2 class="onlyprint">Boundary and Internal Design Models</h2>
                <ul class="twocol">
                    <li>The visible interfaces of the system architecture...
                    </li>
                    <li>..refined with details about the implementation
                    </li>
                </ul>
            </section>
        </section>
            <section id="canonical2" class="">
                <h2>Canonical Models</h2>
                <img src="images/canonical-table.svg" class="svg"/>
</section>
<section id="twinpeaks" class="centered">
    <h2>Modeling = Learning</h2>
    <img src="images/twinpeaks.svg" class="svg"/>
    <div class="fragment">
        <p>The modeling process is non-linear</p>
        <p>Analysis and Synthesis cannot wait for each other</p>
        <p>Architecturally relevant requirements are discovered from the domain while making progress with the design</p>
    </div>
</section>
                <section id="domain2" class="">
                    <h2>Domain Model</h2>
                    <ul>
                        <li>Problem domain description:<ul>
                                <li>
                                    Information (invariants, navigation, snapshots)</li>
                                <li>
                                    Functionality (use-case scenarios, feature models)</li>
                            </ul>
                        </li>
                        <li class="fragment">
                            Main concerns: usability and interoperability</li>
                        <li class="fragment">
                            Define shared vocabulary and understanding</li>
                        <li class="fragment">
                            <b>Avoid analysis paralysis</b>: stop modeling the domain when all your questions about the problem have been answered by the domain experts</li>
                    </ul>
                </section>
                <section id="domain-ex" class="">
                    <h2>Example Domain Model</h2>
                    <ul>
                        <li class="fragment">Music songs are organized in albums</li>
                        <li class="fragment">
                            The same song can be authored by many artists</li>
                        <li class="fragment">
                            Listening to each song costs 0.99 CHF, but short samples can be heard for free</li>
                        <li class="fragment">
                            Songs can be downloaded and also live streamed</li>
                        <li class="fragment">
                            Songs are stored in files of standard MP3 format</li>
                    </ul>
                </section>
                <section id="design2" class="">
                    <h2>Design Model (Boundary)</h2>
                    <img src="images/design-model.svg" class="svg"/>
</section>
                    <section id="design-b-ex" class="">
                        <h2>Example Boundary Model</h2>
                        <ul>
                            <li class="fragment">Streamed songs should begin to play after a max delay of 5 seconds</li>
                            <li class="fragment">
                                Payment messages should be transferred with an encrypted standard protocol</li>
                            <li class="fragment">
                                Songs are stored in files of standard MP3 format</li>
                            <li class="fragment">
                                Playlists cannot be modified while they are being played</li>
                        </ul>
                    </section>
                    <section id="design3" class="">
                        <h2>Design Model (Internal)</h2>
                        <img src="images/design-model.svg" class="svg"/>
</section>
                        <section id="design-i-ex" class="">
                            <h2>Example Internal Model</h2>
                            <ul>
                                <li class="fragment">Playlists are programmed as a double-linked list</li>
                                <li class="fragment">The playback thread should have a high priority</li>
                                <li class="fragment">Sound decoder component built with a MP3 library</li>
                                <li class="fragment">Payment messages should be validated before processing them</li>
                            </ul>
                        </section>


                        <section id="modeling-overview" class="">
                            <h2>Some Modeling Notations</h2>
                            <div class="flex row top">
                                <div style="border: 10px solid red; border-radius: 1em; flex: 1">
                                <h3>Domain</h3>
                            <ul>
                                <li class="fragment">Use Case Scenarios</li>
                                <li class="fragment">Feature Models</li>
                            </ul>
</div>
                                <div style="border: 10px solid blue; border-radius: 1em; flex: 1.5; margin-left: 1em">
                                <h3>Design</h3>
                            <ul>
                                <li class="fragment">C5: Context, Containers, Components, Connectors, Classes</li>
                                <li class="fragment">4+1: Logical, Process, Development, Physical (and Use Cases)</li>
                            </ul>
</div>
                        </section>

<section id="usecase" class="">
          <h2>Use Case Scenarios</h2>
          <p class="credit">Philippe Kruchten</p>
 <ul><li>The model of the architecture can be broken down in scenarios, each illustrated using the other views
</li><li class="fragment">Scenarios help to ensure that the architectural model is complete with respect to requirements
</li><li class="fragment">Scenarios can be <b>prioritized</b> to help driving the development of the system (most critical for success, most expensive to build, most useful, most risky) according to different stakeholders expectations</li></ul>
</section>

<section id="usecaseex2" class="">
<h2>Example Music Player Scenarios</h2>
<ol><li>Browse for new songs
</li><li>Search for interesting songs
</li><li>Play the song sample
</li><li>Pay to hear the entire song
</li><li>Download the purchased song on the device
</li><li>Play the song
</li><li>Play multiple songs on a predefined playlist
</li><li>Play multiple songs in random order
</li><li>Share songs with friends
</li><li>Make a backup of the device's content
</li><li>Suggest related songs
</li><li>Generate a tasteful playlist
</li><li>Display album cover image
</li><li>Show the device's battery status
</li><li>Record sounds with a microphone
</li></ol>
</section>



<section id="asq-scenarios" class="">
<h2>Music Player Scenarios Priority</h2>
        <asq-exercise>

 <asq-buckets-q class="small" mode="1-10" x-matchable="div[buckets]" y-matchable="div[labels]" attr-for-matched="s-name" matched-attribute="matched" label-container="[labels]" matched-class="label-success">

    <asq-stem>What's the priority for these scenarios?</asq-stem>

    <br>
    
      <div buckets="" class="small">
        <div s-name="one" class="bucket">1 (critical)</div>
        <div s-name="two" class="bucket">2</div>
        <div s-name="three" class="bucket">3</div>
        <div s-name="four" class="bucket">4</div>
        <div s-name="five" class="bucket">5</div>
        <div s-name="six" class="bucket">6</div>
        <div s-name="seven" class="bucket">7 (nice to have)</div>
      </div>
      
      <div labels="" class="small">
        <div s-name="a" label="" class="label label-primary">Browse for new songs</div>
        <div s-name="b" label="" class="label label-primary">Play the song sample</div>
        <div s-name="c" label="" class="label label-primary">Pay to hear the entire song</div>
        <div s-name="d" label="" class="label label-primary">Download the purchased song on the device</div>
        <div s-name="e" label="" class="label label-primary">Play the song</div>
        <div s-name="f" label="" class="label label-primary">Play multiple songs on a predefined playlist</div>
        <div s-name="g" label="" class="label label-primary">Suggest related songs</div>
      </div>

      <div style="clear:both; float:none;"/>

  </br></asq-buckets-q>
        </asq-exercise>      
     </section>  


<section id="fm" class="">
          <h2>Feature Models</h2>
          <ul><li>Decompose complex functional or extra-functional requirements into features (required vs optional)</li>
            <li>Represent valid feature combinations for <b>product lines</b></li>
            <li>Constrain the set of all possible products and control feature interactions</li>
            <li>Determine which <b>feature configuration</b> is found in an actual product</li>
            <li>Compare competing products (commodity vs differentiating features)</li></ul>
</section>

<section id="fm-ex" class="">
          <h2>Feature Model Example</h2>
          <img src='images/fm-tree.svg' class="svg"/>
</section>

<section id="fmc" class="">
          <h2>Feature Model Constraints</h2>
          <div class="flex row top">
            <p class="fragment" style="flex:2"><img src="images/fm-req-opt.svg"><br>Required vs. Optional<br>Features</p>
            <p class="fragment" style="flex:1"><img src="images/fm-xor.svg"><br>Alternative Features<br>(Pick one)</p>
            <p class="fragment" style="flex:1.5"><img src="images/fm-or.svg"><br>Feature Combinations<br>(Pick a non-empty subset)</p>
          </div>
          <p class="fragment">Dependencies and Feature Interactions:<br><img src="images/fm-rel.svg" style="width:80%; margin-top: 0.75em"/></p>
          
</section>

<section id="asq-fm" class="">
<h2>Feature Model Constraints</h2>
        <asq-exercise>

 <asq-buckets-q class="small" mode="1-10" x-matchable="div[buckets]" y-matchable="div[labels]" attr-for-matched="s-name" matched-attribute="matched" label-container="[labels]" matched-class="label-success">

    <asq-stem>Which constraints?</asq-stem>

    <br>
    
      <div buckets="" class="small">
        <div s-name="one" class="bucket">Required</div>
        <div s-name="two" class="bucket">Optional</div>
        <div s-name="three" class="bucket">Alternative</div>
        <div s-name="four" class="bucket">Combination</div>
      </div>
      
      <div labels="" class="small">
        <div s-name="a" label="" class="label label-primary">Storage</div>
        <div s-name="f" label="" class="label label-primary">Network</div>
        <div s-name="g" label="" class="label label-primary">Radio: Wifi, BT, 3G, 4G</div>
        <div s-name="b" label="" class="label label-primary">Media.Video</div>
        <div s-name="c" label="" class="label label-primary">Media.Audio</div>
        <div s-name="d" label="" class="label label-primary">Screen: Color, B/W</div>
        <div s-name="e" label="" class="label label-primary">Headphone Jack</div>
      </div>

      <div style="clear:both; float:none;"/>

  </br></asq-buckets-q>
        </asq-exercise>      
     </section>  

<section id="fm-ex2" class="">
          <h2>Constrained Feature Model Example</h2>
          <img src='images/fm-tree-3.svg' class="svg"/>
</section>

<section id="fm-ex3" class="">
          <h2>Feature Configuration</h2>
          <img src='images/fm-tree-ipod.svg' class="svg"/>
</section>

<section id="context" class="">
          <h2>System Context View</h2>
          <img src="images/context.svg" class="svg"/>
          <ul><li>Distinguish what needs to be built from what already exists and define the dependencies and the integration points</li></ul>
</section>


<section id="context2" class="">
          <h2>System Context View</h2>
          <ul><li><b>User</b> roles, personas - who do you expect will use the system? Are the users all the same? How many users can share the system at the same time?</li>
          <li class="fragment"><b>Dependencies</b> - which external systems need to be integrated with the system? are there some open API that let other (unknown or known) systems interact with the system?</li></ul>
</section>

<section id="ex-context" class="center">
          <h3>System Context View Example</h3>
          <img src="images/c4-ex-context.svg" class="svg"/>
</section>

<section id="containers" class="">
          <h2>Containers View</h2>
          <ul><li>What are the main logical execution environments in which the system can run?</li>
          <li>Containers can be deployed separately and indepedently evolved</li></ul>
</section>

<section id="ex-container" class="center">
          <h3>Container View Example</h3>
          <img src="images/c4-ex-container.svg" class="svg"/>
</section>

<section id="containerex" class="">
          <h2>Example Containers</h2>
          <ul><li>Server-side Web application</li>
          <li>Client-side Web application</li>
          <li>Client-side desktop application</li>
          <li>Mobile app</li>
          <li>Server-side console application</li>
          <li>Shell script</li>
          <li>Microservice</li>
          <li>Data store (Database, file system, Key-value, Blob, content delivery network)</li></ul>
</section>

<section id="c4-components" class="">
          <h2>Components View</h2>
          <ul><li>What is the structural decomposition of the software with related functionality encapsulated behind a well-defined interface?</li>
          <li>What are the dependencies between components?</li>
          <li>Are there shared components that will be deployed in multiple containers?</li>
          <li>What is the technology used to build the components? (programming languages and framework decisions)</li></ul>
</section>

<section id="ex-components" class="center">
          <h3>Components View Example</h3>
          <img src="images/c4-ex-component.svg" class="svg"/>
</section>

<section id="c4" class="center">
          <h2>C4</h2>
          <p class="credit">Simon Brown</p>
          <img src="images/cfour.svg" class="svg"/>
</section>

<section id="c4-classes" class="">
          <h2>Classes View</h2>
          <ul><li>What is the structure of the code inside each component?</li>
          <li>How is a component implemented?</li>
          <li>Map the architecture down to the code as a blueprint for software developers</li>
          <li>Representation: UML Class Diagrams</li>
          </ul>
</section>

<section id="c5" class="center">
          <h2>C5</h2>
          <img src="images/cfive.svg" class="svg"/>
</section>

<section id="c5-connectors" class="">
          <h2>Connectors View</h2>
          <ul><li>How are component interfaces interconnected?</li>
          <li>What kind of connector(s) are chosen?</li>
          <li>What is the amount of coupling between components?</li>
          </ul>
          <p>These decisions may depend on the deployment configuration</p>
</section>

<section id="ex-connectors" class="center">
          <h3>Connectors View Example</h3>
          <img src="images/c4-ex-connectors.svg" class="svg"/>
</section>

<section id="fplus1" class="">
          <h2>4+1</h2>
          <p class="credit">Philippe Kruchten</p>
 <img src="images/fourplusone.svg" class="svg"/>
</section>



<section id="vlogical" class="">
          <h2>Logical View</h2>
          <p class="credit">Philippe Kruchten</p>
 <ul><li class="fragment">Decompose the system structure into software components and connectors
</li><li class="fragment">Map functionality/requirements/use cases onto the components
</li><li class="fragment">Concern: Functionality
</li><li class="fragment">Target Audience: Developers and Users
</li></ul>
</section>

<section id="ex-logical" class="">
          <h2>Example Logical View</h2>
 <img src="images/ex-logical.svg" class="svg"/>
</section>



<section id="plantuml-logical">
<div class="flex row top"><pre style="flex: 1"><code contenteditable>@startuml
title Example Logical View

interface " " as MPI
interface " " as SRI
interface " " as CDI
interface " " as PSI

[Customer Database] as CDB
[Music Player] as MP
[User Interface] as UI 
[Payment Service] as PS
[Songs Repository] as SR

MP - MPI
CDI - CDB
SRI -- SR
PSI -- PS

MPI )- UI
UI --( SRI
UI -( CDI
MP --( SRI
CDB --( PSI

@enduml
</code></pre><div><img src="images/plantuml-logical.svg"/>
<button onclick="plant_uml_render('plantuml-logical');">Refresh</button>
<!-- <p class="small"><a target="_blank" href="http://www.plantuml.com/plantuml/uml/dP31JiCm38RF-2cidU2mTnZR6Ah4KDLgSAXsSDkiYvh4LP8o9hHtnsjX8B4JxI6__i_n7tiM8ldOMmDHHwFmuPri9-SJDxeYWozQ7G2qYyhlg58uaPy2hjFahvbdLyp5yegPvWb0iUX3PAiyBYbIIK5jnmjpADPzq1McXexARyT0A3P1QfFlNeEzIH2Ab8vMkOYvyczQm9W0HSwk2PYfZeEEx8y3o3E0TOhJOGHvdAXpOfw9cfvfcWzA6W183TvD9GKsP_DM-215oLN15rDw37gOBBJQTUJ9uWU4FTLyqAx17PcWe6BRiPFd2hifgMeRpxsh5spOu-jUHmNuzPNiQ-L7KXeflP0Lk_XCLk5avScrHZjyvBYNbSsPsmcSVbR-dvWJt7lFXz-MU3FbwjwQJm00"><button>Edit in PlantUML</button></a></p> --></div></div>
</section>

<section id="vprocess" class="">
          <h2>Process View</h2>
          <p class="credit">Philippe Kruchten</p>
          <ul><li>
            Model the dynamic aspects of the architecture:<ul><li>
Which are the active components?
</li><li>Are there concurrent threads of control?
</li><li>Are there multiple distributed processes in the system?
</li><li>What is the behavior of (parts of) the system?</li></ul>
</li><li class="fragment">Describe how processes/threads communicate<br/>(e.g., RPC, Messaging connectors)
</li><li class="fragment">Concern: Functionality, Performance
</li><li class="fragment">Target Audience: Developers
          </li></ul>
</section>


<section id="ex-process" class="centered">
          <h2>Example Process View</h2>
            <p>Use Cases: Browse, Pay and Play For Songs</p>
 <img src="images/ex-process.svg" class="svg"/>
</section>

<section id="plantuml-process">
<div class="flex row top"><pre style="flex: 1"><code contenteditable>@startuml
title Example Process View

participant "User Interface" as UI
participant "Music Player" as MP
participant "Songs Repository" as SR
participant "Customer Database" as CDB
participant "Payment Service" as PS

UI -> SR: Browse Songs
UI -> CDB: Buy Song
CDB -> PS: Charge Customer
UI -> MP: Play Song
MP -> SR: Get Music

@enduml
</code></pre><div><img src="images/plantuml-process.svg"/>
<button onclick="plant_uml_render('plantuml-process');">Refresh</button>
<!-- <p class="small"><a target="_blank" href="http://www.plantuml.com/plantuml/uml/dP6nRkim34NdfwyWih-XQuOYZLCK6GmOSTFEjCpOGYp99QMwHj1_h-8uGBrMYwJBmqjIsaX03j5sAfZG4Jn_eUtJNh3N909lXWQb-iGORNfq0LP78OQz2yGdrBG253ZkbqWUnMWeEXo99o0lba3fNIDmeDwB2Px72IeFIoYB4hmbXXq6h51kjRBTTeaLE5fAXvBuqymD5QLInptyVqocQzYo7uHWAZhBoINfSPn4bMv9J5bho5haXk1UUyRpOdqTPyRpukxyGW6cOPMIit6fBxHmKT9YxGVZ6ZXX9wIiTrwtd0mXSAH5_nVrhq9zRjX7LsU-ymplhGcaO5wLvvhu5gcwXAflPUxF_xVq9sO__9Q4FY8vJLFWjJNwxAw__v3O3Rawsku7"><button>Edit in PlantUML</button></a></p> --></div></div>
</section>

<section id="plantuml-process2">
<div class="flex row top"><pre style="flex: 1"><code contenteditable>@startuml
title Example Process View

participant "User Interface" as UI
participant "Music Player" as MP
participant "Songs Repository" as SR
participant "Customer Database" as CDB
participant "Payment Service" as PS

UI -> SR: Browse Songs
SR -> UI: List of Songs
UI -> CDB: Buy Song
CDB -> PS: Charge Customer

alt payment success

PS -> CDB: ok
UI -> MP: Play Song
MP -> SR: Get Music

else payment fail

PS -> CDB: refused
CDB -> UI: show payment failed error

end

@enduml
</code></pre><div><img src="images/plantuml-process2.svg"/>
<button onclick="plant_uml_render('plantuml-process2');">Refresh</button>
</div></div>
</section>

<section id="vdevel" class="">
          <h2>Development View</h2>
          <p class="credit">Philippe Kruchten</p>
          <ul><li>
            Static organization of the software code artifacts (packages, modules, binaries…)
</li><li class="fragment">A mapping between the logical view and the code is also required
</li><li class="fragment">Concern: Reuse, Portability, Build
</li><li class="fragment">Target Audience: Developers</li></ul>
</section>

<section id="ex-devel" class="">
          <h2>Example Development View</h2>
 <img src="images/ex-devel.svg" class="svg"/>
</section>

<section id="vphysical" class="">
          <h2>Physical View</h2>
          <p class="credit">Philippe Kruchten</p>
          <ul><li>
Define the hardware environment (hosts, networks, storage, etc.) where the software will be deployed
</li><li class="fragment">Different hardware configurations may be used for providing different qualities
</li><li class="fragment"><b>Deployment View</b>: Mapping between logical and physical entities
</li><li class="fragment">Concern: Performance, Scalability, Availability, Reliability
</li><li class="fragment">Target Audience: Operations
</li></ul>
</section>



<section id="ex-deploy" class="">
          <h2>Example Deployment View</h2>
 <img src="images/ex-physical2.svg" class="svg"/>
</section>

<section id="plantuml-deploy">
<div class="flex row top"><pre style="flex: 1"><code contenteditable>@startuml
title Example Deployment View

node "Mobile Phone" {
 [User Interface] as UI
 [Music Player] as MP
 [Songs Repository\n(Cache)] as SRC
}
database "Database" {
 [Customer Database] as CDB
}
folder "File Server" {
 [Master\nSongs Repository] as MSR
}
cloud "Cloud" {
 [Payment Service] as PS
}

CDB -- PS: SWIFT
UI -- MP
SRC - MSR: FTP
UI - SRC
MP - SRC
UI - CDB: HTTPS

@enduml 
</code></pre><div><img src="images/plantuml-deploy.svg"/>
<button onclick="plant_uml_render('plantuml-deploy');">Refresh</button>
<!-- <p class="small"><a target="_blank" href="http://www.plantuml.com/plantuml/uml/dL6nZjim39shho0ojSCDNJDTwpHe1WD6xFI6NWTQPc8XikXIKjEWwB-Nrlc0ecEzY7fyZu_FUem99UN9c-II9_Zq4wTPpntDdkyJXGHV7DsC2JmGR6hkdNQRaGDju9SnyFKKIU0G4iaPBNq3Z70wA5xdw2mq7kya1QqRHLiEbmX7cZcwn79_3cyhj2EzAvJsM1dpsmoOiCUeVhkrMhsg71DFwlUA5rMr-xYepkm7RMtsouOjoG-ILLPZJ2JFuL_pbxNQuwAsdlC0csevLbc3vGUKMMwDrhGBsQWbF3peRGljqs7VcTD1xqj4ZG1QjCSjxBkcu2LMtQn5GLI_XSzTjumpyUh2Z8AJsiOH1xwvS84p-aXcui1s50qDIJ8PvILdtOmXAVjDZ_Pw4SvXgDYpmDFe4XbOlvvb87dfz5wfkhfxVQd_atyGuTlVKAJlcOAbqkX6Pw-1OeJtodsaCEJ9_m40"><button>Edit in PlantUML</button></a></p> --></div></div>
</section>



<section id="asq-plantuml-logical" style="text-align: left" class="no-zoom">
<asq-exercise style="float: left; min-width: 50vw">
    <asq-code-q mode="plantuml" style="min-height: 85vh" font-size="19px">
    <asq-stem></asq-stem>
    <code>title Example Logical View

interface " " as MPI
interface " " as SRI
interface " " as CDI
interface " " as PSI

[Customer Database] as CDB
[Music Player] as MP
[User Interface] as UI 
[Payment Service] as PS
[Songs Repository] as SR

MP - MPI
CDI - CDB
SRI -- SR
PSI -- PS

MPI )- UI
UI --( SRI
UI -( CDI
MP --( SRI
CDB --( PSI</code>
</asq-code-q></asq-exercise><div style="flex: 1; display: flex; flex-direction: column; justify-content: space-between; align-items: center;"><img src="images/plantuml-logical.svg"/><br/>
<button onclick="asq_plant_uml_render('asq-plantuml-logical');">Refresh</button></div>
</section>


<section id="qualityt" class="" data-background-image="images/teapots.png" data-background-position="bottom" data-background-size="contain">
  <h1>Content is more important than representation</h1>
</section>

          <section id="quality" class="">
          <h3>Model Quality</h3>
<ul><li>Ambiguity<ul><li>A model is ambiguous if it leads to more than one interpretation</li><li>Incomplete models can be ambiguous: different people will fill in the gaps in different ways.
</li></ul></li><li class="fragment">Accuracy<ul><li>A model is accurate if it is correct, conforms to fact, or deviates from correctness within acceptable limits.
</li></ul></li><li class="fragment">Precision<ul><li>A model is precise if it is sharply exact or delimited.
</li></ul></li></ul>          
</section>


<section id="asq-model-q2" class="">

        <asq-exercise>

 <asq-buckets-q class="small" mode="1-1" x-matchable="div[buckets]" y-matchable="div[labels]" attr-for-matched="s-name" matched-attribute="matched" label-container="[labels]" matched-class="label-success">

    <asq-stem><h2>Accuracy vs. Precision</h2></asq-stem>

    
      <div buckets="" class="small">
        <div s-name="a1" class="bucket">Accurate, Precise</div>
        <div s-name="b1" class="bucket">Accurate, Imprecise</div>
        <div s-name="a2" class="bucket">Inaccurate, Precise</div>
         <div s-name="b2" class="bucket">Inaccurate, Imprecise</div>
      </div>
      
      <div labels="" class="small">
        <div s-name="a" label="" class="label label-primary"><img src="images/quality-1.png"/></div>
        <div s-name="b" label="" class="label label-primary"><img src="images/quality-2.png"/></div>
        <div s-name="c" label="" class="label label-primary"><img src="images/quality-3.png"/></div>
        <div s-name="d" label="" class="label label-primary"><img src="images/quality-4.png"/></div>
      </div>

      <div style="clear:both; float:none;"/>

  </br></asq-buckets-q>
        </asq-exercise>      
     </section>         


          <section id="q-advice" class="">
          <h3>Model Quality - Advice</h3>
<ul><li>Make sure your architecture is accurate<br/>(a wrong, inconsistent or conflicting architectural decision is a recipe for disaster)
</li><li class="fragment">Sometimes you can even make it complete<br/>(but it will be more expensive, so only do it for critical aspects of the system)
</li><li class="fragment">Precision helps, but avoid over-specifying and over-designing the architecture, especially if the architecture is inaccurate, adding details will not fix it. (developers may be trusted to add missing details)</li></ul>         
</section>






<section id="mda" class="solid">
          <h2>Model-Driven Architecture</h2>
          <ul><li>MDA promotes modeling as the main software design and development activity</li>
            <li>The design is organized around a set of models and model transformations to move within and between different abstraction layers (e.g., code generation, roundtrip engineering, reverse engineering)</li>
          </ul>
          <div>
          <img src="images/mda.svg" class="svg"/>
          </div>
</section>

                        <section id="refs" class="">
                            <h2>References</h2>
                                <ul class="small">
<li>Michael Jackson, Problem Frames: Analyzing and structuring software development problems, Addison-Wesley, 2001
</li><li>Richard N. Taylor, Nenad Medvidovic, Eric M. Dashofy, Software Architecture: Foundations, Theory and Practice, John-Wiley, January 2009
</li><li>Philippe Kruchten, Architectural Blueprints—The “4+1” View Model of Software Architecture, IEEE Software 12 (6). November 1995, pp. 42-50
</li><li>Scott W. Ambler, <a href="http://www.agilemodeling.com/">Agile Modeling</a> </li><li>I. Asimov, The Relativity of Wrong, The Skeptical Inquirer, Fall 1989, Vol. 14, No. 1, Pp. 35-44</li>
<li>J. Cleland-Huang, R. S. Hanmer, S. Supakkul and M. Mirakhorli, <a href="http://ieeexplore.ieee.org/document/6470589/">The Twin Peaks of Requirements and Architecture</a> IEEE Software, vol. 30, no. 2, pp. 24-29, March-April 2013.</li>
<li>Simon Brown, <a href="https://leanpub.com/visualising-software-architecture/read">The Art of Visualizing Software Architecture</a>, Leanpub</li>
<li>Nick Rozanski, Eoin Woods, Software Systems Architecture: Working with Stakeholders using Viewpoints and Perspectives, Addison-Wesley, 2012
</li><li>plantUML: <a href="http://plantuml.com/sitemap-language-specification">DSL Specification</a>, <a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">Online Server</a>, <a href="http://plantuml.com/download">Download</a></li></ul>
                        </section>
                        <script>
                        function setup_pdf() {
                            //hide box on the right and the toolbar for the highlight solution
                            document.querySelector("#asq-coa asq-buckets-q").value = '{"a":["b","e","f","h"],"ac":["d","g","a"],"c":["c","j"]}';
                            document.querySelector("#asq-fm asq-buckets-q").value = '{"one":["a","c","e"],"two":["f","b"],"four":["g"],"three":["d"]}';
                            document.querySelector("#asq-model-q2 asq-buckets-q").value = '{"a1":["d"],"a2":["c"],"b2":["a"],"b1":["b"]}';
                        }
                        </script>
                        <script>
    /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = zip_deflate(src);
 */

/* constant parameters */
var zip_WSIZE = 32768;      // Sliding Window size
var zip_STORED_BLOCK = 0;
var zip_STATIC_TREES = 1;
var zip_DYN_TREES    = 2;

/* for deflate */
var zip_DEFAULT_LEVEL = 6;
var zip_FULL_SEARCH = true;
var zip_INBUFSIZ = 32768;   // Input buffer size
var zip_INBUF_EXTRA = 64;   // Extra buffer
var zip_OUTBUFSIZ = 1024 * 8;
var zip_window_size = 2 * zip_WSIZE;
var zip_MIN_MATCH = 3;
var zip_MAX_MATCH = 258;
var zip_BITS = 16;
// for SMALL_MEM
var zip_LIT_BUFSIZE = 0x2000;
var zip_HASH_BITS = 13;
// for MEDIUM_MEM
// var zip_LIT_BUFSIZE = 0x4000;
// var zip_HASH_BITS = 14;
// for BIG_MEM
// var zip_LIT_BUFSIZE = 0x8000;
// var zip_HASH_BITS = 15;
if(zip_LIT_BUFSIZE > zip_INBUFSIZ)
    alert("error: zip_INBUFSIZ is too small");
if((zip_WSIZE<<1) > (1<<zip_BITS))
    alert("error: zip_WSIZE is too large");
if(zip_HASH_BITS > zip_BITS-1)
    alert("error: zip_HASH_BITS is too large");
if(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)
    alert("error: Code too clever");
var zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;
var zip_HASH_SIZE = 1 << zip_HASH_BITS;
var zip_HASH_MASK = zip_HASH_SIZE - 1;
var zip_WMASK = zip_WSIZE - 1;
var zip_NIL = 0; // Tail of hash chains
var zip_TOO_FAR = 4096;
var zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;
var zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;
var zip_SMALLEST = 1;
var zip_MAX_BITS = 15;
var zip_MAX_BL_BITS = 7;
var zip_LENGTH_CODES = 29;
var zip_LITERALS =256;
var zip_END_BLOCK = 256;
var zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;
var zip_D_CODES = 30;
var zip_BL_CODES = 19;
var zip_REP_3_6 = 16;
var zip_REPZ_3_10 = 17;
var zip_REPZ_11_138 = 18;
var zip_HEAP_SIZE = 2 * zip_L_CODES + 1;
var zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /
               zip_MIN_MATCH);

/* variables */
var zip_free_queue;
var zip_qhead, zip_qtail;
var zip_initflag;
var zip_outbuf = null;
var zip_outcnt, zip_outoff;
var zip_complete;
var zip_window;
var zip_d_buf;
var zip_l_buf;
var zip_prev;
var zip_bi_buf;
var zip_bi_valid;
var zip_block_start;
var zip_ins_h;
var zip_hash_head;
var zip_prev_match;
var zip_match_available;
var zip_match_length;
var zip_prev_length;
var zip_strstart;
var zip_match_start;
var zip_eofile;
var zip_lookahead;
var zip_max_chain_length;
var zip_max_lazy_match;
var zip_compr_level;
var zip_good_match;
var zip_nice_match;
var zip_dyn_ltree;
var zip_dyn_dtree;
var zip_static_ltree;
var zip_static_dtree;
var zip_bl_tree;
var zip_l_desc;
var zip_d_desc;
var zip_bl_desc;
var zip_bl_count;
var zip_heap;
var zip_heap_len;
var zip_heap_max;
var zip_depth;
var zip_length_code;
var zip_dist_code;
var zip_base_length;
var zip_base_dist;
var zip_flag_buf;
var zip_last_lit;
var zip_last_dist;
var zip_last_flags;
var zip_flags;
var zip_flag_bit;
var zip_opt_len;
var zip_static_len;
var zip_deflate_data;
var zip_deflate_pos;

/* constant tables */
var zip_extra_lbits = new Array(
    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0);
var zip_extra_dbits = new Array(
    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13);
var zip_extra_blbits = new Array(
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7);
var zip_bl_order = new Array(
    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);
var zip_configuration_table = new Array(
    new zip_DeflateConfiguration(0,    0,   0,    0),
    new zip_DeflateConfiguration(4,    4,   8,    4),
    new zip_DeflateConfiguration(4,    5,  16,    8),
    new zip_DeflateConfiguration(4,    6,  32,   32),
    new zip_DeflateConfiguration(4,    4,  16,   16),
    new zip_DeflateConfiguration(8,   16,  32,   32),
    new zip_DeflateConfiguration(8,   16, 128,  128),
    new zip_DeflateConfiguration(8,   32, 128,  256),
    new zip_DeflateConfiguration(32, 128, 258, 1024),
    new zip_DeflateConfiguration(32, 258, 258, 4096));

/* objects (deflate) */

function zip_DeflateCT() {
    this.fc = 0; // frequency count or bit string
    this.dl = 0; // father node in Huffman tree or length of bit string
}

function zip_DeflateTreeDesc() {
    this.dyn_tree = null;   // the dynamic tree
    this.static_tree = null;    // corresponding static tree or NULL
    this.extra_bits = null; // extra bits for each code or NULL
    this.extra_base = 0;    // base index for extra_bits
    this.elems = 0;     // max number of elements in the tree
    this.max_length = 0;    // max bit length for the codes
    this.max_code = 0;      // largest code with non zero frequency
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function zip_DeflateConfiguration(a, b, c, d) {
    this.good_length = a; // reduce lazy search above this match length
    this.max_lazy = b;    // do not perform lazy search above this match length
    this.nice_length = c; // quit search above this match length
    this.max_chain = d;
}

function zip_DeflateBuffer() {
    this.next = null;
    this.len = 0;
    this.ptr = new Array(zip_OUTBUFSIZ);
    this.off = 0;
}

/* routines (deflate) */

function zip_deflate_start(level) {
    var i;

    if(!level)
    level = zip_DEFAULT_LEVEL;
    else if(level < 1)
    level = 1;
    else if(level > 9)
    level = 9;

    zip_compr_level = level;
    zip_initflag = false;
    zip_eofile = false;
    if(zip_outbuf != null)
    return;

    zip_free_queue = zip_qhead = zip_qtail = null;
    zip_outbuf = new Array(zip_OUTBUFSIZ);
    zip_window = new Array(zip_window_size);
    zip_d_buf = new Array(zip_DIST_BUFSIZE);
    zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);
    zip_prev = new Array(1 << zip_BITS);
    zip_dyn_ltree = new Array(zip_HEAP_SIZE);
    for(i = 0; i < zip_HEAP_SIZE; i++)
    zip_dyn_ltree[i] = new zip_DeflateCT();
    zip_dyn_dtree = new Array(2*zip_D_CODES+1);
    for(i = 0; i < 2*zip_D_CODES+1; i++)
    zip_dyn_dtree[i] = new zip_DeflateCT();
    zip_static_ltree = new Array(zip_L_CODES+2);
    for(i = 0; i < zip_L_CODES+2; i++)
    zip_static_ltree[i] = new zip_DeflateCT();
    zip_static_dtree = new Array(zip_D_CODES);
    for(i = 0; i < zip_D_CODES; i++)
    zip_static_dtree[i] = new zip_DeflateCT();
    zip_bl_tree = new Array(2*zip_BL_CODES+1);
    for(i = 0; i < 2*zip_BL_CODES+1; i++)
    zip_bl_tree[i] = new zip_DeflateCT();
    zip_l_desc = new zip_DeflateTreeDesc();
    zip_d_desc = new zip_DeflateTreeDesc();
    zip_bl_desc = new zip_DeflateTreeDesc();
    zip_bl_count = new Array(zip_MAX_BITS+1);
    zip_heap = new Array(2*zip_L_CODES+1);
    zip_depth = new Array(2*zip_L_CODES+1);
    zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);
    zip_dist_code = new Array(512);
    zip_base_length = new Array(zip_LENGTH_CODES);
    zip_base_dist = new Array(zip_D_CODES);
    zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));
}

function zip_deflate_end() {
    zip_free_queue = zip_qhead = zip_qtail = null;
    zip_outbuf = null;
    zip_window = null;
    zip_d_buf = null;
    zip_l_buf = null;
    zip_prev = null;
    zip_dyn_ltree = null;
    zip_dyn_dtree = null;
    zip_static_ltree = null;
    zip_static_dtree = null;
    zip_bl_tree = null;
    zip_l_desc = null;
    zip_d_desc = null;
    zip_bl_desc = null;
    zip_bl_count = null;
    zip_heap = null;
    zip_depth = null;
    zip_length_code = null;
    zip_dist_code = null;
    zip_base_length = null;
    zip_base_dist = null;
    zip_flag_buf = null;
}

function zip_reuse_queue(p) {
    p.next = zip_free_queue;
    zip_free_queue = p;
}

function zip_new_queue() {
    var p;

    if(zip_free_queue != null)
    {
    p = zip_free_queue;
    zip_free_queue = zip_free_queue.next;
    }
    else
    p = new zip_DeflateBuffer();
    p.next = null;
    p.len = p.off = 0;

    return p;
}

function zip_head1(i) {
    return zip_prev[zip_WSIZE + i];
}

function zip_head2(i, val) {
    return zip_prev[zip_WSIZE + i] = val;
}

/* put_byte is used for the compressed output, put_ubyte for the
 * uncompressed output. However unlzw() uses window for its
 * suffix table instead of its output buffer, so it does not use put_ubyte
 * (to be cleaned up).
 */
function zip_put_byte(c) {
    zip_outbuf[zip_outoff + zip_outcnt++] = c;
    if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)
    zip_qoutbuf();
}

/* Output a 16 bit value, lsb first */
function zip_put_short(w) {
    w &= 0xffff;
    if(zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {
    zip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);
    zip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);
    } else {
    zip_put_byte(w & 0xff);
    zip_put_byte(w >>> 8);
    }
}

/* ==========================================================================
 * Insert string s in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of s are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
function zip_INSERT_STRING() {
    zip_ins_h = ((zip_ins_h << zip_H_SHIFT)
         ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))
    & zip_HASH_MASK;
    zip_hash_head = zip_head1(zip_ins_h);
    zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;
    zip_head2(zip_ins_h, zip_strstart);
}

/* Send a code of the given tree. c and tree must not have side effects */
function zip_SEND_CODE(c, tree) {
    zip_send_bits(tree[c].fc, tree[c].dl);
}

/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. dist_code[256] and dist_code[257] are never
 * used.
 */
function zip_D_CODE(dist) {
    return (dist < 256 ? zip_dist_code[dist]
        : zip_dist_code[256 + (dist>>7)]) & 0xff;
}

/* ==========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function zip_SMALLER(tree, n, m) {
    return tree[n].fc < tree[m].fc ||
      (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);
}

/* ==========================================================================
 * read string data
 */
function zip_read_buff(buff, offset, n) {
    var i;
    for(i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)
    buff[offset + i] =
        zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;
    return i;
}

/* ==========================================================================
 * Initialize the "longest match" routines for a new file
 */
function zip_lm_init() {
    var j;

    /* Initialize the hash table. */
    for(j = 0; j < zip_HASH_SIZE; j++)
//  zip_head2(j, zip_NIL);
    zip_prev[zip_WSIZE + j] = 0;
    /* prev will be initialized on the fly */

    /* Set the default configuration parameters:
     */
    zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;
    zip_good_match     = zip_configuration_table[zip_compr_level].good_length;
    if(!zip_FULL_SEARCH)
    zip_nice_match = zip_configuration_table[zip_compr_level].nice_length;
    zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;

    zip_strstart = 0;
    zip_block_start = 0;

    zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);
    if(zip_lookahead <= 0) {
    zip_eofile = true;
    zip_lookahead = 0;
    return;
    }
    zip_eofile = false;
    /* Make sure that we always have enough lookahead. This is important
     * if input comes from a device such as a tty.
     */
    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)
    zip_fill_window();

    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
     * not important since only literal bytes will be emitted.
     */
    zip_ins_h = 0;
    for(j = 0; j < zip_MIN_MATCH - 1; j++) {
//      UPDATE_HASH(ins_h, window[j]);
    zip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;
    }
}

/* ==========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 */
function zip_longest_match(cur_match) {
    var chain_length = zip_max_chain_length; // max hash chain length
    var scanp = zip_strstart; // current string
    var matchp;     // matched string
    var len;        // length of current match
    var best_len = zip_prev_length; // best match length so far

    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);

    var strendp = zip_strstart + zip_MAX_MATCH;
    var scan_end1 = zip_window[scanp + best_len - 1];
    var scan_end  = zip_window[scanp + best_len];

    /* Do not waste too much time if we already have a good match: */
    if(zip_prev_length >= zip_good_match)
    chain_length >>= 2;

//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

    do {
//    Assert(cur_match < encoder->strstart, "no future");
    matchp = cur_match;

    /* Skip to next match if the match length cannot increase
        * or if the match length is less than 2:
    */
    if(zip_window[matchp + best_len]    != scan_end  ||
       zip_window[matchp + best_len - 1]    != scan_end1 ||
       zip_window[matchp]           != zip_window[scanp] ||
       zip_window[++matchp]         != zip_window[scanp + 1]) {
        continue;
    }

    /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
    scanp += 2;
    matchp++;

    /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
    do {
    } while(zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        zip_window[++scanp] == zip_window[++matchp] &&
        scanp < strendp);

      len = zip_MAX_MATCH - (strendp - scanp);
      scanp = strendp - zip_MAX_MATCH;

      if(len > best_len) {
      zip_match_start = cur_match;
      best_len = len;
      if(zip_FULL_SEARCH) {
          if(len >= zip_MAX_MATCH) break;
      } else {
          if(len >= zip_nice_match) break;
      }

      scan_end1  = zip_window[scanp + best_len-1];
      scan_end   = zip_window[scanp + best_len];
      }
    } while((cur_match = zip_prev[cur_match & zip_WMASK]) > limit
        && --chain_length != 0);

    return best_len;
}

/* ==========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead, and sets eofile if end of input file.
 * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
 * OUT assertions: at least one byte has been read, or eofile is set;
 *    file reads are performed for at least two bytes (required for the
 *    translate_eol option).
 */
function zip_fill_window() {
    var n, m;

    // Amount of free space at the end of the window.
    var more = zip_window_size - zip_lookahead - zip_strstart;

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if(more == -1) {
    /* Very unlikely, but possible on 16 bit machine if strstart == 0
         * and lookahead == 1 (input done one byte at time)
         */
    more--;
    } else if(zip_strstart >= zip_WSIZE + zip_MAX_DIST) {
    /* By the IN assertion, the window is not empty so we can't confuse
         * more == 0 with more == 64K on a 16 bit machine.
         */
//  Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");

//  System.arraycopy(window, WSIZE, window, 0, WSIZE);
    for(n = 0; n < zip_WSIZE; n++)
        zip_window[n] = zip_window[n + zip_WSIZE];
      
    zip_match_start -= zip_WSIZE;
    zip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */
    zip_block_start -= zip_WSIZE;

    for(n = 0; n < zip_HASH_SIZE; n++) {
        m = zip_head1(n);
        zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);
    }
    for(n = 0; n < zip_WSIZE; n++) {
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
        m = zip_prev[n];
        zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);
    }
    more += zip_WSIZE;
    }
    // At this point, more >= 2
    if(!zip_eofile) {
    n = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);
    if(n <= 0)
        zip_eofile = true;
    else
        zip_lookahead += n;
    }
}

/* ==========================================================================
 * Processes a new input file and return its compressed length. This
 * function does not perform lazy evaluationof matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function zip_deflate_fast() {
    while(zip_lookahead != 0 && zip_qhead == null) {
    var flush; // set if current block must be flushed

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    zip_INSERT_STRING();

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if(zip_hash_head != zip_NIL &&
       zip_strstart - zip_hash_head <= zip_MAX_DIST) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        zip_match_length = zip_longest_match(zip_hash_head);
        /* longest_match() sets match_start */
        if(zip_match_length > zip_lookahead)
        zip_match_length = zip_lookahead;
    }
    if(zip_match_length >= zip_MIN_MATCH) {
//      check_match(strstart, match_start, match_length);

        flush = zip_ct_tally(zip_strstart - zip_match_start,
                 zip_match_length - zip_MIN_MATCH);
        zip_lookahead -= zip_match_length;

        /* Insert new strings in the hash table only if the match length
         * is not too large. This saves time but degrades compression.
         */
        if(zip_match_length <= zip_max_lazy_match) {
        zip_match_length--; // string at strstart already in hash table
        do {
            zip_strstart++;
            zip_INSERT_STRING();
            /* strstart never exceeds WSIZE-MAX_MATCH, so there are
             * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
             * these bytes are garbage, but it does not matter since
             * the next lookahead bytes will be emitted as literals.
             */
        } while(--zip_match_length != 0);
        zip_strstart++;
        } else {
        zip_strstart += zip_match_length;
        zip_match_length = 0;
        zip_ins_h = zip_window[zip_strstart] & 0xff;
//      UPDATE_HASH(ins_h, window[strstart + 1]);
        zip_ins_h = ((zip_ins_h<<zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;

//#if MIN_MATCH != 3
//      Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif

        }
    } else {
        /* No match, output a literal byte */
        flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);
        zip_lookahead--;
        zip_strstart++;
    }
    if(flush) {
        zip_flush_block(0);
        zip_block_start = zip_strstart;
    }

    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)
        zip_fill_window();
    }
}

function zip_deflate_better() {
    /* Process the input block. */
    while(zip_lookahead != 0 && zip_qhead == null) {
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    zip_INSERT_STRING();

    /* Find the longest match, discarding those <= prev_length.
     */
    zip_prev_length = zip_match_length;
    zip_prev_match = zip_match_start;
    zip_match_length = zip_MIN_MATCH - 1;

    if(zip_hash_head != zip_NIL &&
       zip_prev_length < zip_max_lazy_match &&
       zip_strstart - zip_hash_head <= zip_MAX_DIST) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        zip_match_length = zip_longest_match(zip_hash_head);
        /* longest_match() sets match_start */
        if(zip_match_length > zip_lookahead)
        zip_match_length = zip_lookahead;

        /* Ignore a length 3 match if it is too distant: */
        if(zip_match_length == zip_MIN_MATCH &&
           zip_strstart - zip_match_start > zip_TOO_FAR) {
        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        zip_match_length--;
        }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if(zip_prev_length >= zip_MIN_MATCH &&
       zip_match_length <= zip_prev_length) {
        var flush; // set if current block must be flushed

//      check_match(strstart - 1, prev_match, prev_length);
        flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,
                 zip_prev_length - zip_MIN_MATCH);

        /* Insert in hash table all strings up to the end of the match.
         * strstart-1 and strstart are already inserted.
         */
        zip_lookahead -= zip_prev_length - 1;
        zip_prev_length -= 2;
        do {
        zip_strstart++;
        zip_INSERT_STRING();
        /* strstart never exceeds WSIZE-MAX_MATCH, so there are
         * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
         * these bytes are garbage, but it does not matter since the
         * next lookahead bytes will always be emitted as literals.
         */
        } while(--zip_prev_length != 0);
        zip_match_available = 0;
        zip_match_length = zip_MIN_MATCH - 1;
        zip_strstart++;
        if(flush) {
        zip_flush_block(0);
        zip_block_start = zip_strstart;
        }
    } else if(zip_match_available != 0) {
        /* If there was no match at the previous position, output a
         * single literal. If there was a match but the current match
         * is longer, truncate the previous match to a single literal.
         */
        if(zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {
        zip_flush_block(0);
        zip_block_start = zip_strstart;
        }
        zip_strstart++;
        zip_lookahead--;
    } else {
        /* There is no previous match to compare with, wait for
         * the next step to decide.
         */
        zip_match_available = 1;
        zip_strstart++;
        zip_lookahead--;
    }

    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)
        zip_fill_window();
    }
}

function zip_init_deflate() {
    if(zip_eofile)
    return;
    zip_bi_buf = 0;
    zip_bi_valid = 0;
    zip_ct_init();
    zip_lm_init();

    zip_qhead = null;
    zip_outcnt = 0;
    zip_outoff = 0;

    if(zip_compr_level <= 3)
    {
    zip_prev_length = zip_MIN_MATCH - 1;
    zip_match_length = 0;
    }
    else
    {
    zip_match_length = zip_MIN_MATCH - 1;
    zip_match_available = 0;
    }

    zip_complete = false;
}

/* ==========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function zip_deflate_internal(buff, off, buff_size) {
    var n;

    if(!zip_initflag)
    {
    zip_init_deflate();
    zip_initflag = true;
    if(zip_lookahead == 0) { // empty
        zip_complete = true;
        return 0;
    }
    }

    if((n = zip_qcopy(buff, off, buff_size)) == buff_size)
    return buff_size;

    if(zip_complete)
    return n;

    if(zip_compr_level <= 3) // optimized for speed
    zip_deflate_fast();
    else
    zip_deflate_better();
    if(zip_lookahead == 0) {
    if(zip_match_available != 0)
        zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);
    zip_flush_block(1);
    zip_complete = true;
    }
    return n + zip_qcopy(buff, n + off, buff_size - n);
}

function zip_qcopy(buff, off, buff_size) {
    var n, i, j;

    n = 0;
    while(zip_qhead != null && n < buff_size)
    {
    i = buff_size - n;
    if(i > zip_qhead.len)
        i = zip_qhead.len;
//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
    for(j = 0; j < i; j++)
        buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];
    
    zip_qhead.off += i;
    zip_qhead.len -= i;
    n += i;
    if(zip_qhead.len == 0) {
        var p;
        p = zip_qhead;
        zip_qhead = zip_qhead.next;
        zip_reuse_queue(p);
    }
    }

    if(n == buff_size)
    return n;

    if(zip_outoff < zip_outcnt) {
    i = buff_size - n;
    if(i > zip_outcnt - zip_outoff)
        i = zip_outcnt - zip_outoff;
    // System.arraycopy(outbuf, outoff, buff, off + n, i);
    for(j = 0; j < i; j++)
        buff[off + n + j] = zip_outbuf[zip_outoff + j];
    zip_outoff += i;
    n += i;
    if(zip_outcnt == zip_outoff)
        zip_outcnt = zip_outoff = 0;
    }
    return n;
}

/* ==========================================================================
 * Allocate the match buffer, initialize the various tables and save the
 * location of the internal file attribute (ascii/binary) and method
 * (DEFLATE/STORE).
 */
function zip_ct_init() {
    var n;  // iterates over tree elements
    var bits;   // bit counter
    var length; // length value
    var code;   // code value
    var dist;   // distance index

    if(zip_static_dtree[0].dl != 0) return; // ct_init already called

    zip_l_desc.dyn_tree     = zip_dyn_ltree;
    zip_l_desc.static_tree  = zip_static_ltree;
    zip_l_desc.extra_bits   = zip_extra_lbits;
    zip_l_desc.extra_base   = zip_LITERALS + 1;
    zip_l_desc.elems        = zip_L_CODES;
    zip_l_desc.max_length   = zip_MAX_BITS;
    zip_l_desc.max_code     = 0;

    zip_d_desc.dyn_tree     = zip_dyn_dtree;
    zip_d_desc.static_tree  = zip_static_dtree;
    zip_d_desc.extra_bits   = zip_extra_dbits;
    zip_d_desc.extra_base   = 0;
    zip_d_desc.elems        = zip_D_CODES;
    zip_d_desc.max_length   = zip_MAX_BITS;
    zip_d_desc.max_code     = 0;

    zip_bl_desc.dyn_tree    = zip_bl_tree;
    zip_bl_desc.static_tree = null;
    zip_bl_desc.extra_bits  = zip_extra_blbits;
    zip_bl_desc.extra_base  = 0;
    zip_bl_desc.elems       = zip_BL_CODES;
    zip_bl_desc.max_length  = zip_MAX_BL_BITS;
    zip_bl_desc.max_code    = 0;

    // Initialize the mapping length (0..255) -> length code (0..28)
    length = 0;
    for(code = 0; code < zip_LENGTH_CODES-1; code++) {
    zip_base_length[code] = length;
    for(n = 0; n < (1<<zip_extra_lbits[code]); n++)
        zip_length_code[length++] = code;
    }
    // Assert (length == 256, "ct_init: length != 256");

    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    zip_length_code[length-1] = code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for(code = 0 ; code < 16; code++) {
    zip_base_dist[code] = dist;
    for(n = 0; n < (1<<zip_extra_dbits[code]); n++) {
        zip_dist_code[dist++] = code;
    }
    }
    // Assert (dist == 256, "ct_init: dist != 256");
    dist >>= 7; // from now on, all distances are divided by 128
    for( ; code < zip_D_CODES; code++) {
    zip_base_dist[code] = dist << 7;
    for(n = 0; n < (1<<(zip_extra_dbits[code]-7)); n++)
        zip_dist_code[256 + dist++] = code;
    }
    // Assert (dist == 256, "ct_init: 256+dist != 512");

    // Construct the codes of the static literal tree
    for(bits = 0; bits <= zip_MAX_BITS; bits++)
    zip_bl_count[bits] = 0;
    n = 0;
    while(n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }
    while(n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }
    while(n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }
    while(n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);

    /* The static distance tree is trivial: */
    for(n = 0; n < zip_D_CODES; n++) {
    zip_static_dtree[n].dl = 5;
    zip_static_dtree[n].fc = zip_bi_reverse(n, 5);
    }

    // Initialize the first block of the first file:
    zip_init_block();
}

/* ==========================================================================
 * Initialize a new block.
 */
function zip_init_block() {
    var n; // iterates over tree elements

    // Initialize the trees.
    for(n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;
    for(n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;
    for(n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;

    zip_dyn_ltree[zip_END_BLOCK].fc = 1;
    zip_opt_len = zip_static_len = 0;
    zip_last_lit = zip_last_dist = zip_last_flags = 0;
    zip_flags = 0;
    zip_flag_bit = 1;
}

/* ==========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function zip_pqdownheap(
    tree,   // the tree to restore
    k) {    // node to move down
    var v = zip_heap[k];
    var j = k << 1; // left son of k

    while(j <= zip_heap_len) {
    // Set j to the smallest of the two sons:
    if(j < zip_heap_len &&
       zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))
        j++;

    // Exit if v is smaller than both sons
    if(zip_SMALLER(tree, v, zip_heap[j]))
        break;

    // Exchange v with the smallest son
    zip_heap[k] = zip_heap[j];
    k = j;

    // And continue down the tree, setting j to the left son of k
    j <<= 1;
    }
    zip_heap[k] = v;
}

/* ==========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function zip_gen_bitlen(desc) { // the tree descriptor
    var tree        = desc.dyn_tree;
    var extra       = desc.extra_bits;
    var base        = desc.extra_base;
    var max_code    = desc.max_code;
    var max_length  = desc.max_length;
    var stree       = desc.static_tree;
    var h;      // heap index
    var n, m;       // iterate over the tree elements
    var bits;       // bit length
    var xbits;      // extra bits
    var f;      // frequency
    var overflow = 0;   // number of elements with bit length too large

    for(bits = 0; bits <= zip_MAX_BITS; bits++)
    zip_bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap

    for(h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {
    n = zip_heap[h];
    bits = tree[tree[n].dl].dl + 1;
    if(bits > max_length) {
        bits = max_length;
        overflow++;
    }
    tree[n].dl = bits;
    // We overwrite tree[n].dl which is no longer needed

    if(n > max_code)
        continue; // not a leaf node

    zip_bl_count[bits]++;
    xbits = 0;
    if(n >= base)
        xbits = extra[n - base];
    f = tree[n].fc;
    zip_opt_len += f * (bits + xbits);
    if(stree != null)
        zip_static_len += f * (stree[n].dl + xbits);
    }
    if(overflow == 0)
    return;

    // This happens for example on obj2 and pic of the Calgary corpus

    // Find the first bit length which could increase:
    do {
    bits = max_length - 1;
    while(zip_bl_count[bits] == 0)
        bits--;
    zip_bl_count[bits]--;       // move one leaf down the tree
    zip_bl_count[bits + 1] += 2;    // move one overflow item as its brother
    zip_bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
    } while(overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for(bits = max_length; bits != 0; bits--) {
    n = zip_bl_count[bits];
    while(n != 0) {
        m = zip_heap[--h];
        if(m > max_code)
        continue;
        if(tree[m].dl != bits) {
        zip_opt_len += (bits - tree[m].dl) * tree[m].fc;
        tree[m].fc = bits;
        }
        n--;
    }
    }
}

  /* ==========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */
function zip_gen_codes(tree,    // the tree to decorate
           max_code) {  // largest code with non zero frequency
    var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length
    var code = 0;       // running code value
    var bits;           // bit index
    var n;          // code index

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for(bits = 1; bits <= zip_MAX_BITS; bits++) {
    code = ((code + zip_bl_count[bits-1]) << 1);
    next_code[bits] = code;
    }

    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
//    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
//      "inconsistent bit counts");
//    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for(n = 0; n <= max_code; n++) {
    var len = tree[n].dl;
    if(len == 0)
        continue;
    // Now reverse the bits
    tree[n].fc = zip_bi_reverse(next_code[len]++, len);

//      Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
//    n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
    }
}

/* ==========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function zip_build_tree(desc) { // the tree descriptor
    var tree    = desc.dyn_tree;
    var stree   = desc.static_tree;
    var elems   = desc.elems;
    var n, m;       // iterate over heap elements
    var max_code = -1;  // largest code with non zero frequency
    var node = elems;   // next internal node of the tree

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    zip_heap_len = 0;
    zip_heap_max = zip_HEAP_SIZE;

    for(n = 0; n < elems; n++) {
    if(tree[n].fc != 0) {
        zip_heap[++zip_heap_len] = max_code = n;
        zip_depth[n] = 0;
    } else
        tree[n].dl = 0;
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while(zip_heap_len < 2) {
    var xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[xnew].fc = 1;
    zip_depth[xnew] = 0;
    zip_opt_len--;
    if(stree != null)
        zip_static_len -= stree[xnew].dl;
    // new is 0 or 1 so it does not have extra bits
    }
    desc.max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for(n = zip_heap_len >> 1; n >= 1; n--)
    zip_pqdownheap(tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    do {
    n = zip_heap[zip_SMALLEST];
    zip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];
    zip_pqdownheap(tree, zip_SMALLEST);

    m = zip_heap[zip_SMALLEST];  // m = node of next least frequency

    // keep the nodes sorted by frequency
    zip_heap[--zip_heap_max] = n;
    zip_heap[--zip_heap_max] = m;

    // Create a new node father of n and m
    tree[node].fc = tree[n].fc + tree[m].fc;
//  depth[node] = (char)(MAX(depth[n], depth[m]) + 1);
    if(zip_depth[n] > zip_depth[m] + 1)
        zip_depth[node] = zip_depth[n];
    else
        zip_depth[node] = zip_depth[m] + 1;
    tree[n].dl = tree[m].dl = node;

    // and insert the new node in the heap
    zip_heap[zip_SMALLEST] = node++;
    zip_pqdownheap(tree, zip_SMALLEST);

    } while(zip_heap_len >= 2);

    zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    zip_gen_bitlen(desc);

    // The field len is now set, we can generate the bit codes
    zip_gen_codes(tree, max_code);
}

/* ==========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree. Updates opt_len to take into account the repeat
 * counts. (The contribution of the bit length codes will be added later
 * during the construction of bl_tree.)
 */
function zip_scan_tree(tree,// the tree to be scanned
               max_code) {  // and its largest code of non zero frequency
    var n;          // iterates over all tree elements
    var prevlen = -1;       // last emitted length
    var curlen;         // length of current code
    var nextlen = tree[0].dl;   // length of next code
    var count = 0;      // repeat count of the current code
    var max_count = 7;      // max repeat count
    var min_count = 4;      // min repeat count

    if(nextlen == 0) {
    max_count = 138;
    min_count = 3;
    }
    tree[max_code + 1].dl = 0xffff; // guard

    for(n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[n + 1].dl;
    if(++count < max_count && curlen == nextlen)
        continue;
    else if(count < min_count)
        zip_bl_tree[curlen].fc += count;
    else if(curlen != 0) {
        if(curlen != prevlen)
        zip_bl_tree[curlen].fc++;
        zip_bl_tree[zip_REP_3_6].fc++;
    } else if(count <= 10)
        zip_bl_tree[zip_REPZ_3_10].fc++;
    else
        zip_bl_tree[zip_REPZ_11_138].fc++;
    count = 0; prevlen = curlen;
    if(nextlen == 0) {
        max_count = 138;
        min_count = 3;
    } else if(curlen == nextlen) {
        max_count = 6;
        min_count = 3;
    } else {
        max_count = 7;
        min_count = 4;
    }
    }
}

  /* ==========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */
function zip_send_tree(tree, // the tree to be scanned
           max_code) { // and its largest code of non zero frequency
    var n;          // iterates over all tree elements
    var prevlen = -1;       // last emitted length
    var curlen;         // length of current code
    var nextlen = tree[0].dl;   // length of next code
    var count = 0;      // repeat count of the current code
    var max_count = 7;      // max repeat count
    var min_count = 4;      // min repeat count

    /* tree[max_code+1].dl = -1; */  /* guard already set */
    if(nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }

    for(n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[n+1].dl;
    if(++count < max_count && curlen == nextlen) {
        continue;
    } else if(count < min_count) {
        do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);
    } else if(curlen != 0) {
        if(curlen != prevlen) {
        zip_SEND_CODE(curlen, zip_bl_tree);
        count--;
        }
        // Assert(count >= 3 && count <= 6, " 3_6?");
        zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);
        zip_send_bits(count - 3, 2);
    } else if(count <= 10) {
        zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);
        zip_send_bits(count-3, 3);
    } else {
        zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);
        zip_send_bits(count-11, 7);
    }
    count = 0;
    prevlen = curlen;
    if(nextlen == 0) {
        max_count = 138;
        min_count = 3;
    } else if(curlen == nextlen) {
        max_count = 6;
        min_count = 3;
    } else {
        max_count = 7;
        min_count = 4;
    }
    }
}

/* ==========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function zip_build_bl_tree() {
    var max_blindex;  // index of last bit length code of non zero freq

    // Determine the bit length frequencies for literal and distance trees
    zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);
    zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);

    // Build the bit length tree:
    zip_build_tree(zip_bl_desc);
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for(max_blindex = zip_BL_CODES-1; max_blindex >= 3; max_blindex--) {
    if(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    zip_opt_len += 3*(max_blindex+1) + 5+5+4;
//    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
//      encoder->opt_len, encoder->static_len));

    return max_blindex;
}

/* ==========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree
    var rank; // index in bl_order

//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
//      "too many codes");
//    Tracev((stderr, "\nbl counts: "));
    zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt
    zip_send_bits(dcodes-1,   5);
    zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt
    for(rank = 0; rank < blcodes; rank++) {
//      Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    zip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);
    }

    // send the literal tree
    zip_send_tree(zip_dyn_ltree,lcodes-1);

    // send the distance tree
    zip_send_tree(zip_dyn_dtree,dcodes-1);
}

/* ==========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function zip_flush_block(eof) { // true if this is the last block for a file
    var opt_lenb, static_lenb; // opt_len and static_len in bytes
    var max_blindex;    // index of last bit length code of non zero freq
    var stored_len; // length of input block

    stored_len = zip_strstart - zip_block_start;
    zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items

    // Construct the literal and distance trees
    zip_build_tree(zip_l_desc);
//    Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
//      encoder->opt_len, encoder->static_len));

    zip_build_tree(zip_d_desc);
//    Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
//      encoder->opt_len, encoder->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = zip_build_bl_tree();

    // Determine the best encoding. Compute first the block length in bytes
    opt_lenb    = (zip_opt_len   +3+7)>>3;
    static_lenb = (zip_static_len+3+7)>>3;

//    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
//     opt_lenb, encoder->opt_len,
//     static_lenb, encoder->static_len, stored_len,
//     encoder->last_lit, encoder->last_dist));

    if(static_lenb <= opt_lenb)
    opt_lenb = static_lenb;
    if(stored_len + 4 <= opt_lenb // 4: two words for the lengths
       && zip_block_start >= 0) {
    var i;

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    zip_send_bits((zip_STORED_BLOCK<<1)+eof, 3);  /* send block type */
    zip_bi_windup();         /* align on byte boundary */
    zip_put_short(stored_len);
    zip_put_short(~stored_len);

      // copy block
/*
      p = &window[block_start];
      for(i = 0; i < stored_len; i++)
    put_byte(p[i]);
*/
    for(i = 0; i < stored_len; i++)
        zip_put_byte(zip_window[zip_block_start + i]);

    } else if(static_lenb == opt_lenb) {
    zip_send_bits((zip_STATIC_TREES<<1)+eof, 3);
    zip_compress_block(zip_static_ltree, zip_static_dtree);
    } else {
    zip_send_bits((zip_DYN_TREES<<1)+eof, 3);
    zip_send_all_trees(zip_l_desc.max_code+1,
               zip_d_desc.max_code+1,
               max_blindex+1);
    zip_compress_block(zip_dyn_ltree, zip_dyn_dtree);
    }

    zip_init_block();

    if(eof != 0)
    zip_bi_windup();
}

/* ==========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function zip_ct_tally(
    dist, // distance of matched string
    lc) { // match length-MIN_MATCH or unmatched char (if dist==0)
    zip_l_buf[zip_last_lit++] = lc;
    if(dist == 0) {
    // lc is the unmatched char
    zip_dyn_ltree[lc].fc++;
    } else {
    // Here, lc is the match length - MIN_MATCH
    dist--;         // dist = match distance - 1
//      Assert((ush)dist < (ush)MAX_DIST &&
//       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
//       (ush)D_CODE(dist) < (ush)D_CODES,  "ct_tally: bad match");

    zip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;
    zip_dyn_dtree[zip_D_CODE(dist)].fc++;

    zip_d_buf[zip_last_dist++] = dist;
    zip_flags |= zip_flag_bit;
    }
    zip_flag_bit <<= 1;

    // Output the flags if they fill a byte
    if((zip_last_lit & 7) == 0) {
    zip_flag_buf[zip_last_flags++] = zip_flags;
    zip_flags = 0;
    zip_flag_bit = 1;
    }
    // Try to guess if it is profitable to stop the current block here
    if(zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {
    // Compute an upper bound for the compressed length
    var out_length = zip_last_lit * 8;
    var in_length = zip_strstart - zip_block_start;
    var dcode;

    for(dcode = 0; dcode < zip_D_CODES; dcode++) {
        out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);
    }
    out_length >>= 3;
//      Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
//       encoder->last_lit, encoder->last_dist, in_length, out_length,
//       100L - out_length*100L/in_length));
    if(zip_last_dist < parseInt(zip_last_lit/2) &&
       out_length < parseInt(in_length/2))
        return true;
    }
    return (zip_last_lit == zip_LIT_BUFSIZE-1 ||
        zip_last_dist == zip_DIST_BUFSIZE);
    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

  /* ==========================================================================
   * Send the block data compressed using the given Huffman trees
   */
function zip_compress_block(
    ltree,  // literal tree
    dtree) {    // distance tree
    var dist;       // distance of matched string
    var lc;     // match length or unmatched char (if dist == 0)
    var lx = 0;     // running index in l_buf
    var dx = 0;     // running index in d_buf
    var fx = 0;     // running index in flag_buf
    var flag = 0;   // current flags
    var code;       // the code to send
    var extra;      // number of extra bits to send

    if(zip_last_lit != 0) do {
    if((lx & 7) == 0)
        flag = zip_flag_buf[fx++];
    lc = zip_l_buf[lx++] & 0xff;
    if((flag & 1) == 0) {
        zip_SEND_CODE(lc, ltree); /* send a literal byte */
//  Tracecv(isgraph(lc), (stderr," '%c' ", lc));
    } else {
        // Here, lc is the match length - MIN_MATCH
        code = zip_length_code[lc];
        zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code
        extra = zip_extra_lbits[code];
        if(extra != 0) {
        lc -= zip_base_length[code];
        zip_send_bits(lc, extra); // send the extra length bits
        }
        dist = zip_d_buf[dx++];
        // Here, dist is the match distance - 1
        code = zip_D_CODE(dist);
//  Assert (code < D_CODES, "bad d_code");

        zip_SEND_CODE(code, dtree);   // send the distance code
        extra = zip_extra_dbits[code];
        if(extra != 0) {
        dist -= zip_base_dist[code];
        zip_send_bits(dist, extra);   // send the extra distance bits
        }
    } // literal or match pair ?
    flag >>= 1;
    } while(lx < zip_last_lit);

    zip_SEND_CODE(zip_END_BLOCK, ltree);
}

/* ==========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
var zip_Buf_size = 16; // bit size of bi_buf
function zip_send_bits(
    value,  // value to send
    length) {   // number of bits
    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if(zip_bi_valid > zip_Buf_size - length) {
    zip_bi_buf |= (value << zip_bi_valid);
    zip_put_short(zip_bi_buf);
    zip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));
    zip_bi_valid += length - zip_Buf_size;
    } else {
    zip_bi_buf |= value << zip_bi_valid;
    zip_bi_valid += length;
    }
}

/* ==========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function zip_bi_reverse(
    code,   // the value to invert
    len) {  // its bit length
    var res = 0;
    do {
    res |= code & 1;
    code >>= 1;
    res <<= 1;
    } while(--len > 0);
    return res >> 1;
}

/* ==========================================================================
 * Write out any remaining bits in an incomplete byte.
 */
function zip_bi_windup() {
    if(zip_bi_valid > 8) {
    zip_put_short(zip_bi_buf);
    } else if(zip_bi_valid > 0) {
    zip_put_byte(zip_bi_buf);
    }
    zip_bi_buf = 0;
    zip_bi_valid = 0;
}

function zip_qoutbuf() {
    if(zip_outcnt != 0) {
    var q, i;
    q = zip_new_queue();
    if(zip_qhead == null)
        zip_qhead = zip_qtail = q;
    else
        zip_qtail = zip_qtail.next = q;
    q.len = zip_outcnt - zip_outoff;
//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);
    for(i = 0; i < q.len; i++)
        q.ptr[i] = zip_outbuf[zip_outoff + i];
    zip_outcnt = zip_outoff = 0;
    }
}

function zip_deflate(str, level) {
    var out, buff;
    var i, j;

    zip_deflate_data = str;
    zip_deflate_pos = 0;
    if(typeof level == "undefined")
    level = zip_DEFAULT_LEVEL;
    zip_deflate_start(level);

    buff = new Array(1024);
    out = "";
    while((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {
    for(j = 0; j < i; j++)
        out += String.fromCharCode(buff[j]);
    }
    zip_deflate_data = null; // G.C.
    return out;
}

GID = function(id){ return document.getElementById(id) };

function encode64(data) {
 r = "";
 for (i=0; i<data.length; i+=3) {
  if (i+2==data.length) {
   r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
  } else if (i+1==data.length) {
   r += append3bytes(data.charCodeAt(i), 0, 0);
  } else {
   r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), data.charCodeAt(i+2));
  }
}
return r;
}

function append3bytes(b1, b2, b3) {
c1 = b1 >> 2;
c2 = ((b1 & 0x3) << 4) | (b2 >> 4);
c3 = ((b2 & 0xF) << 2) | (b3 >> 6);
c4 = b3 & 0x3F;
r = "";
r += encode6bit(c1 & 0x3F);
r += encode6bit(c2 & 0x3F);
r += encode6bit(c3 & 0x3F);
r += encode6bit(c4 & 0x3F);
return r;
}

function encode6bit(b) {
if (b < 10) {
 return String.fromCharCode(48 + b);
}
b -= 10;
if (b < 26) {
 return String.fromCharCode(65 + b);
}
b -= 26;
if (b < 26) {
 return String.fromCharCode(97 + b);
}
b -= 26;
if (b == 0) {
 return '-';
}
if (b == 1) {
 return '_';
}
return '?';
}
</script>

<script>function plant_uml_render(src,dest){a=unescape(encodeURIComponent(document.querySelector("#"+src+" code").innerText));document.querySelector("#"+src+" img").src="http://www.plantuml.com/plantuml/img/"+encode64(zip_deflate(a,9))};

function asq_plant_uml_render(src,dest){a=unescape(encodeURIComponent(document.querySelector("#"+src+" asq-code-q").value));document.querySelector("#"+src+" img").src="http://www.plantuml.com/plantuml/img/"+encode64(zip_deflate(a,9))};
</script>
