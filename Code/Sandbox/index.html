<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dagre Interactive Demo</title>

  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <script src="bower_components/graphlib/dist/graphlib.core.js"></script>
  <script src="bower_components/dagre/dist/dagre.core.js"></script>
  <script src="bower_components/dagre-d3/dist/dagre-d3.core.js"></script>
  <link rel="stylesheet/less" type="text/css" href="bower_components/tyles.less" />
  <script src="data.js"></script>
  <!-- <script type="text/javascript" src="setup.js"></script> -->
  <link rel="stylesheet" href="styles.css">

  <body>
    <div id="Container" style="display: flex">
      <div class="dropdown" style="float: left">
        <button class="dropbtn" onmouseover="displayClients()">Dropdown</button>
      </div>
      <select id="multiSelect" multiple="multiple">
      </select>
      <button id="multiSelectForm" type="submit"/> Draw </button>
      <div id="Btns">

      </div>
    </div>
    <svg> </g></svg>
  </body>
  <script>
  // Input related code goes here

  // Create the dropdown-list of Clients.
  var displayClients = function(){
    var div = document.getElementsByClassName("dropdown");
    var str = '<div class="dropdown-content"> '
    for(var client in clients){
      str+=('<a onmouseover="displayTimePeriods(\''+ client +'\')" onclick="drawGraph(\''+client +'\')"> '+ client + '</a> ')
    }
    str+=('</div>')
    div[0].innerHTML += str;
  }

  var displayTimePeriods = function(clientIP){
    var client = this.clients[clientIP];
    var el = document.getElementById("multiSelect");
    var form = document.getElementById("multiSelectForm");
    var timePeriods = differenceThreshold(client);
    var str = "";
    for(let i = 0; i < timePeriods.length; i++){
      str += '<option value=\''+i+'\'> Time Period '+ i + '</option>'
    }
    form.onclick = function(){
      getSelectedPeriods(timePeriods);
    }
    el.innerHTML = str;
  }

  //Draw the Graph for the selected IP.
  var drawGraph = function(dataObject){
    var g = new dagreD3.graphlib.Graph()
    .setGraph({})
    .setDefaultEdgeLabel(function() { return {}; });

    // Here we"re setting nodeclass, which is used by our custom drawNodes function
    // below.
    var obj;
    var endConnections = []
    var nodes = []
    var incomingXorNodes = {}
    if(dataObject.identify === "tp"){
      var timePeriods = dataObject.data;
      for(let i = 0; i < timePeriods.length; i++){
        var start = "start-"+i;
        g.setNode("start-"+i, {shape: "circle", class : "start"});
        g.setNode("end-"+i, {shape: "circle", style: "stroke-width: 4; stroke: black"});
        obj = seqPreservingComparison(timePeriods[i], timePeriods[i].length, nodes, start, incomingXorNodes, "end-"+i)
        incomingXorNodes = obj.incomingXorNodes;
        endConnections.push(obj.endConection);
        nodes = obj.nodes;
      }
    }
    else{
      g.setNode("start-0", { shape: "circle" });
      g.setNode("end-0", {shape: "circle", style: "stroke-width: 4; stroke: black"})
      var length = clients[dataObject].length;
      var client = clients[dataObject];
      var start = "start-0"
      obj = seqPreservingComparison(client, length, nodes, start, incomingXorNodes, "end-0");
      incomingXorNodes = obj.incomingXorNodes;
      console.log(incomingXorNodes);
      endConnections.push(obj.endConection);
      nodes = obj.nodes;
    }
    console.log(nodes);
    var endConection = obj.endConection;
    var totalRequestsData = totalNumberOfRequests(nodes);
    var totalRequests = totalRequestsData.total;
    var maxRequests = totalRequestsData.maxRequests;
    for(var key in nodes){
      var size = Object.keys(nodes[key]).length;
      if(size == 1){
        var status = Object.keys(nodes[key])[0]
        g.setNode(key+' '+status, { shape: "rect", label : nodes[key][status].statusArray[0].key + '\n' + status + '\n' + nodes[key][status].statusArray.length, class:"type-Request method-"+key+' '+status});
        if(nodes[key][status].outgoingXOR){
          g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
          var str = "inXOR-"+key
          g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
        else if((nodes[key][status].statusArray.length) > 1){
          var str = "inXOR-"+key
          g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
      }
      else{
        var st = Object.keys(nodes[key])[0]
        g.setNode(key, {shape: "rect", label: nodes[key][st].statusArray[0].key + '\n' + totalRequests[key], class: "type-Request method-"+key});
        g.setNode("middleXOR-"+key,{label: "XOR", shape: "diamond", class: "type-XOR"});
        var str = "inXOR-"+key
        g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        for(var status in nodes[key]){
          g.setNode(key+' '+status, {shape: "rect", label : status + '\n' + nodes[key][status].statusArray.length, class:"type-Response method-"+key+' '+status});
          if(nodes[key][status].outgoingXOR){
            g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
          }
        }
      }
    }

    //Set Up Edges
    for(var key in nodes){
      var str = "inXOR-"+key
      var size = Object.keys(nodes[key]).length
      var delayAvg = computeDelayAvg(nodes, key, "total");
      if(size == 1){
        var status = Object.keys(nodes[key])[0]
        if(nodes[key][status].outgoingXOR){
          // console.log(key,status);
          g.setEdge(key+' '+status,"XOR-"+key+' '+status, {class: "edge-thickness-" + nodes[key][status].statusArray.length});
          // g.setEdge("inXOR-"+key, key+' '+status, {label: "delayAvg: "+ delayAvg});
        }
        else{
          g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status,{class: "edge-thickness-" + nodes[key][status].statusArray.length})
        }
        if(nodes[key][status].statusArray.length > 1){
          g.setEdge("inXOR-"+key, key+' '+status, {class: "edge-thickness-" + nodes[key][status].statusArray.length})
          for(var space in incomingXorNodes[key]){
            var len = incomingXorNodes[key][space][0].length;
            if(len == 1){
              g.setEdge(incomingXorNodes[key][space][0][0], str, {class: "edge-thickness-" + incomingXorNodes[key][space].length})
            }
            else{
              g.setEdge(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], str, {class: "edge-thickness-" + incomingXorNodes[key][space].length})
            }
          }
        }
      }
      else{
        var str1 = "middleXOR-"+key;
        // g.setEdge(str,key,{label: "Delay Average:"+delayAvg});
        g.setEdge(str,key, {class: "edge-thickness-"+totalRequests[key]});
        g.setEdge(key,str1, {class: "edge-thickness-"+totalRequests[key]});
        for(var status in nodes[key]){
          g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%", class: "edge-thickness-" +nodes[key][status].statusArray.length})
          // g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%"+'\n'+"Delay Avg:" + (computeDelayAvg(nodes, key, status)), labelType: "html"});
          if(nodes[key][status].outgoingXOR){
            g.setEdge(key+' '+status, "XOR-"+key+' '+status, {class: "edge-thickness-" + nodes[key][status].statusArray.length});
          }
          for(var space in incomingXorNodes[key]){
            var len = incomingXorNodes[key][space][0].length;
            if(len == 1){
              g.setEdge(incomingXorNodes[key][space][0][0], str, {class: "edge-thickness-" + incomingXorNodes[key][space].length})
            }
            else{
              g.setEdge(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], str, {class: "edge-thickness-" + incomingXorNodes[key][space].length})
            }
          }
        }
      }
    }

    //Set Up End Node
    for(let i = 0; i < endConnections.length; i++){
      var endConection = endConnections[i];
      var spaces =  endConection.e1.split(' ');
      var k = spaces[0]
      var s = spaces[1]
      if(nodes[k][s].outgoingXOR){
        g.setEdge("XOR-"+k+' '+s, "end-"+i, {class: "edge-thickness-1"})
      }
      else{
        g.setEdge(k+' '+s, "end-"+i, {class: "edge-thickness-1"});
      }
    }
    // console.log(g);
    g.nodes().forEach(function(v) {
      var node = g.node(v);
      // Round the corners of the nodes
      node.rx = node.ry = 5;
    });

    setNodeClasses(g, nodes, totalRequestsData)
    var red = [255,0,0];
    var yellow = [255,255,0];
    var gradient_style = setupGradientStyleSheet("totalRequest",maxRequests,red,yellow);
    setEdgeThicknessStyleSheet("edge-thickness", maxRequests);
    var container = document.getElementById("Btns");
    while (container.firstChild){
      container.removeChild(container.firstChild);
    }
    var btn1 = document.createElement("BUTTON")
    var t1 = document.createTextNode("Enable Node Coloring");
    btn1.appendChild(t1);
    btn1.onclick = enableColoring
    var btn2 = document.createElement("BUTTON")
    var t2 = document.createTextNode("Disable Node Coloring");
    btn2.appendChild(t2);
    btn2.onclick = disableColoring
    // btn2.onclick = function(gradient_style){
    //   gradient_style.setAttribute("media","print");
    // }
    container.appendChild(btn1);
    container.appendChild(btn2);


    var svg = d3.select("svg");
    svg.selectAll("*").remove();
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom().on("zoom", function() {
      inner.attr("transform", d3.event.transform);
    });
    svg.call(zoom);

    // Create the renderer
    var render = new dagreD3.render();
    // Run the renderer. This is what draws the final graph.
    render(inner, g);
    // Center the graph
    var initialScale = 0.2;
    svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));
    svg.selectAll("g.node.start").on("click", function(id) { var _node = g.node(id); console.log("Clicked " + id,_node); });
  }

// Edge Thickness
var setEdgeThicknessStyleSheet = function(class_prefix, steps){
  // Create the <style> tag
  var style = document.createElement('style')

  // Add a media (and/or media query) here if you'd like!
  // style.setAttribute("media", "print")
  // style.setAttribute("media", "only screen and (max-width : 1024px)")

  // WebKit hack :(
  style.appendChild(document.createTextNode(""));

  // Add the <style> element to the page
  document.head.appendChild(style);
  var w = 1.125;
  var sheet = style.sheet;
  var MAX = steps;
  for (let N = 1; N<=MAX; N++){
    w*=1.5;
    var st = "stroke: #333; fill: black; stroke-width: "+ w +"px;";
    var clazz = "."+class_prefix+"-"+N;
    sheet.insertRule(clazz+" { "+st+" }");

  }
  return style; //the caller can use setAttribute("media") to enable/disable
}
//Enable Coloring, Set Media to Screen
var enableColoring = function(){
  var x = document.getElementsByTagName("STYLE")[0];
  console.log(x);
  x.setAttribute("media", "screen");
}
var disableColoring = function(){
  var x = document.getElementsByTagName("STYLE")[0];
  if(undefined === x) return;
  else x.setAttribute("media", "print");
}

//Disable Coloring, Set Media to Print
  //Simple Comparison Algorithm
  var simpleComparison = function(clients, clientIP){
    var size = clients[clientIP].length
    var responses = [];
    var marked = new Array(size).fill(false);
    for(let i = 0; i < size; i++){
      responses[i] = [];
      if(!marked[i]){
        responses[i].push({id : i, client : clients[clientIP][i]})
        marked[i] = true;
        for(let j = i+1; j < size; j++){
          if((clients[clientIP][j].status != responses[i][0].client.status) && (clients[clientIP][j].method == responses[i][0].client.method) &&
          clients[clientIP][j].location == responses[i][0].client.location){
            marked[j] = true;
            responses[i].push({id : j, client : clients[clientIP][j] })
          }
        }
      }
    }
    return responses;
  }
  var differenceThreshold = function(client){
    let avg = 0;
    let min = Number.MAX_VALUE;
    let max = Number.MIN_VALUE;
    var timePeriods = [];
    for(let i = 1; i < client.length; i++){
      let date = new Date(client[i-1].datetime)
      let date1 = new Date(client[i].datetime)
      let diff = Math.abs(date1-date);
      avg+=diff;
      if(max < diff) max = diff
      if(min > diff) min = diff;
    }
    avg /= (client.length-1);
    let days =  (avg / (1000*60*60*24));
    let diffThreshold = (min+max)/2;
    var timeP = []
    timeP.push(client[0])
    for(let i = 1; i < client.length; i++){
      let date = new Date(client[i-1].datetime)
      let date1 = new Date(client[i].datetime)
      let diff = Math.abs(date1-date);
      if(diff > diffThreshold){
        timePeriods.push(timeP);
        timeP = []
      }
      timeP.push(client[i]);
    }
    return timePeriods;
  }

  //Sequence Preserving Comparison
  var seqPreservingComparison = function(client, length, nodes, start, incomingXorNodes, endName){
    var prev = start;
    var prevId = start;
    var endConection = {};
    var edges = [];
    var finalEnd;
    var k = null;
    var s = null;
    var l;
    for(let i = 0; i < length; i++){
      var str = client[i].method + client[i].location
      var key = client[i].method + ' ' + client[i].location;
      var status = client[i].status;
      if(nodes[str] === undefined){
        nodes[str] = {}
      }
      var node = {
        "id" : i,
        "startId" : prevId,
        "endId" : i,
        "dataNode" : client[i],
        "start" : prev,
        "end" : str+' '+status,
        "key" : key,
        "finalEnd" : start,
      }
      let delay = computeDelay(nodes, node.start, node.dataNode);
      if(k == null || s == null){
        k = str;
        s = status;
      }
      else{
        l = nodes[k][s].statusArray.length;
        nodes[k][s].statusArray[l-1].finalEnd = key;
        k = str;
        s = status;
      }
      if(nodes[str][status] === undefined){
        nodes[str][status] = {
          statusArray : [],
          outgoingXOR : false,
          delayArray : [],
        }
      }
      nodes[str][status].delayArray.push(delay);
      prev = str + ' ' + status;
      prevId = i;
      nodes[str][status].statusArray.push(node)
      if(i == (length-1)){
        endConection.e1 = prev;
        l = nodes[str][status].statusArray.length;
        nodes[k][s].statusArray[l-1].finalEnd = endName;
      }
    }
    nodes = outgoingXOR(nodes);
    nodes = incomingXOR(nodes, start, incomingXorNodes);
    nodes.endConection = endConection;
    return nodes;
  }
  var outgoingXOR = function(nodes){
    var counterArray = []
    var xorTitle;
    for(var key in nodes){
      for(var status in nodes[key]){
        if(nodes[key][status].statusArray.length > 1){
          let check = false;
          for(let i = 0; i < nodes[key][status].statusArray.length; i++){
            for(let j = i + 1; j < nodes[key][status].statusArray.length; j++){
              if(nodes[key][status].statusArray[i].finalEnd != nodes[key][status].statusArray[j].finalEnd){
                check = true;
              }
            }
          }
          if(check){
            xorTitle = key + ' ' + status;
            nodes[key][status].outgoingXOR = true;
            counterArray.push(xorTitle);
          }
        }
      }
    }
    for(var key in nodes){
      for(var status in nodes[key]){
        for(let i = 0; i < nodes[key][status].statusArray.length; i++){
          for(let j = 0; j < counterArray.length; j++){
            if(counterArray[j] == nodes[key][status].statusArray[i].start){
              // console.log(counterArray[j]);
              nodes[key][status].statusArray[i].start = "XOR-" + counterArray[j];
            }
          }
        }
      }
    }
    return nodes;
  }
  var incomingXOR = function(nodes, start, incomingXorNodes){
    var incomingXorKeys = []
    var keyCounter = 0;
    var keyArray = []
    for(var key in nodes){
      keyArray.push(key);
    }
    for(let i = 0; i < keyArray.length; i++){
      for(var key in nodes){
        for(var status in nodes[key]){
          for(let j = 0; j < nodes[key][status].statusArray.length; j++){
            let spaces = nodes[key][status].statusArray[j].end.split(' ');
            if((spaces[0] == start && i == 0) || spaces[0] == "XOR-"+keyArray[i] || spaces[0] == keyArray[i]){
              keyCounter++;
            }
          }
        }
      }
      if(keyCounter > 1){
        incomingXorKeys.push({ "key" : keyArray[i], "id" : i})
      }
      keyCounter = 0;
    }
    for(let i = 0; i < incomingXorKeys.length; i++){
      for(var key in nodes){
        if(key == incomingXorKeys[i].key){
          for(var status in nodes[key]){
            for(let j = 0; j < nodes[key][status].statusArray.length; j++){
              if(nodes[key][status].statusArray[j].start !== "inXOR-" + key){
                var spaces = nodes[key][status].statusArray[j].start
                var start = nodes[key][status].statusArray[j].start;
                nodes[key][status].statusArray[j].start = "inXOR-" + key
                if(incomingXorNodes[key] === undefined){
                  incomingXorNodes[key] = {};
                }
                if(incomingXorNodes[key][spaces] === undefined){
                  incomingXorNodes[key][spaces] = [];
                }
                incomingXorNodes[key][spaces].push(spaces.split(' '));
              }
            }
          }
        }
      }
    }
    var obj = {
      "nodes" : nodes,
      incomingXorNodes : incomingXorNodes,
    }
    return obj;
  }
  var getSelectedPeriods = function(timePeriods){
    var elem = document.getElementById("multiSelect");
    var result = [];
    var options = elem && elem.options;
    var opt;
    for (let i=0, iLen=options.length; i<iLen; i++) {
      opt = options[i];

      if (opt.selected) {
        result.push(timePeriods[parseInt(opt.value)] || timePeriods[parseInt(opt.text)]);
      }
    }
    var obj = {
      "identify" : "tp",
      "data" : result
    }
    drawGraph(obj);
  }
  var totalNumberOfRequests = function(nodes){
    var counter = 0;
    var totalNumberOfRequests = {}
    var max = Number.MIN_VALUE;
    for(var key in nodes){
      for(var status in nodes[key]){
        counter += (nodes[key][status].statusArray.length);
      }
      totalNumberOfRequests[key] = counter;
      if(max < counter){
        max = counter;
      }
      counter = 0;
    }
    return {"total" : totalNumberOfRequests,
    "maxRequests" : max};
  }
  var getGradientColor = function(color1, color2, weight){
    var w1 = weight;
    var w2 = 1 - w1;
    var rgb = [Math.round(color1[0] * w1 + color2[0] * w2),
    Math.round(color1[1] * w1 + color2[1] * w2),
    Math.round(color1[2] * w1 + color2[2] * w2)];
    return rgb;
  }
  var calculatePercentage = function(min, max, val){
    if((max-min) == 0) return 1;
    return (((val - min)) / (max - min))
  }
  //Set Classes of Nodes, corresponding with their number of requests.
  var setNodeClasses = function(g, nodes, totalRequestsData){
    var totalRequests = totalRequestsData.total;
    var maxRequests = totalRequestsData.maxRequests;
    var red = [255,0,0];
    var yellow = [255,255,0];
    for(var key in g._nodes){
      if(g._nodes[key].shape == "rect"){
        var spaces = key.split(' ');
        if(spaces[1] === undefined){
          // var percent = calculatePercentage(1, maxRequests, totalRequests[key]);
          // var color = getGradientColor(red, yellow, (percent));
          // g._nodes[key].style = "fill: rgb("+color[0]+","+color[1]+","+color[2]+")"
          g._nodes[key].class += " totalRequest-"+totalRequests[key];
        }
        else{
          // var percent = calculatePercentage(1, maxRequests, nodes[spaces[0]][spaces[1]].statusArray.length);
          // var color = getGradientColor(red, yellow, (percent));
          // g._nodes[key].style = "fill: rgb("+color[0]+","+color[1]+","+color[2]+")"
          g._nodes[key].class += " totalRequest-"+nodes[spaces[0]][spaces[1]].statusArray.length;
        }
      }
    }
  }

  var setupGradientStyleSheet = function(class_prefix, steps, first_color, second_color){

    // Create the <style> tag
    var style = document.getElementsByTagName("STYLE")[0];
    if(style != undefined){
      var st = document.getElementsByTagName("STYLE")
      st[0].remove();
    }
    style = document.createElement('style')

    // Add a media (and/or media query) here if you'd like!
    style.setAttribute("media", "print")
    // style.setAttribute("media", "only screen and (max-width : 1024px)")

    // WebKit hack :(
    style.appendChild(document.createTextNode(""));

    // Add the <style> element to the page
    document.head.appendChild(style);

    var sheet = style.sheet;
    var MAX = steps;
    for (let N = 1; N<=MAX; N++){
      var percent = calculatePercentage(1, MAX, N);
      var color = getGradientColor(first_color, second_color, (percent));
      var st = "fill: rgb("+color[0]+","+color[1]+","+color[2]+")";
      var clazz = "."+class_prefix+"-"+N;

      sheet.insertRule(clazz+" { "+st+" }");

    }
    return style; //the caller can use setAttribute("media") to enable/disable
  }
  var roundUp = function(num, precision){
  precision = Math.pow(10, precision)
  return Math.ceil(num * precision) / precision
}
  var computeDelay = function(nodes, startNode, endNode){
      if(startNode.includes("start")) return 0;
      startNode = startNode.split(' ');
      let length = nodes[startNode[0]][startNode[1]].statusArray.length;
      let startDate = new Date(nodes[startNode[0]][startNode[1]].statusArray[length-1].dataNode.datetime)
      let endDate = new Date(endNode.datetime);
      return (endDate-startDate);
  }
  var computeDelayAvg = function(nodes, key, st){
    var avg = 0;
    var counter = 0;
    if(st == "total"){
      let counter = 0;
      for(var status in nodes[key]){
        for(let i = 0; i < nodes[key][status].delayArray.length; i++){
          avg += nodes[key][status].delayArray[i];
          counter++;
        }
      }
      return (avg/counter);
    }
    for(let i = 0; i < nodes[key][st].delayArray.length; i++){
      avg += nodes[key][st].delayArray[i];
    }
    return (avg/nodes[key][st].delayArray.length);
  }
</script>
</html>
