<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dagre Interactive Demo</title>

  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <script src="bower_components/graphlib/dist/graphlib.core.js"></script>
  <script src="bower_components/dagre/dist/dagre.core.js"></script>
  <script src="bower_components/dagre-d3/dist/dagre-d3.core.js"></script>
  <link rel="stylesheet/less" type="text/css" href="bower_components/tyles.less" />
  <script src="data.js"></script>
  <script src="sqrfun.js"></script>
  <!-- <script type="text/javascript" src="setup.js"></script> -->
  <link rel="stylesheet" href="styles.css">

  <body>
    <div id="Container" style="display: flex">
      <div class="dropdown" style="float: left">
        <button class="dropbtn" onmouseover="displayClients()">Dropdown</button>
      </div>
      <select id="multiSelect" multiple="multiple">
      </select>
      <button id="multiSelectForm" type="submit"/> Draw </button>
      <div id="Btns">
      </div>
      <div id="VisualizationConfig" style="display: none">
        Node Frequency Coloring: <input type="checkbox" id="nfc" onclick="myFunction()"> <br />
        Edge Frequency Thickness: <input type="checkbox" id="eft" onclick="myFunction1()"> <br />
        Edge Delay Coloring: <input type="checkbox" id="edc" onclick="myFunction2()">
      </div>
    </div>
    <svg> </g></svg>
  </body>
  <script>
  // Input related code goes here

  // Create the dropdown-list of Clients.
  var displayClients = function(){
    var div = document.getElementsByClassName("dropdown");
    var str = '<div class="dropdown-content"> '
    for(var client in clients){
      str+=('<a onmouseover="displayTimePeriods(\''+ client +'\')" onclick="drawGraph(\''+client +'\')"> '+ client + '</a> ')
    }
    str+=('</div>')
    div[0].innerHTML += str;
  }

  var displayTimePeriods = function(clientIP){
    var client = this.clients[clientIP];
    var el = document.getElementById("multiSelect");
    var form = document.getElementById("multiSelectForm");
    var timePeriods = differenceThreshold(client);
    var str = "";
    for(let i = 0; i < timePeriods.length; i++){
      str += '<option value=\''+i+'\'> Time Period '+ i + '</option>'
    }
    form.onclick = function(){
      getSelectedPeriods(timePeriods);
    }
    el.innerHTML = str;
  }
  var fixVisualizationConfig = function(nfc, eft, edc){
    nfc.checked = false;
    eft.checked = false;
    edc.checked = false;
    deleteStyles();
  }
  //Draw the Graph for the selected IP.
  var drawGraph = function(dataObject){
    var g = new dagreD3.graphlib.Graph()
    .setGraph({})
    .setDefaultEdgeLabel(function() { return {}; });

    var nfc = document.getElementById("nfc");
    var eft = document.getElementById("eft");
    var edc = document.getElementById("edc");
    fixVisualizationConfig(nfc, eft, edc);
    // Here we"re setting nodeclass, which is used by our custom drawNodes function
    // below.
    var obj;
    var endConnections = []
    var nodes = []
    var incomingXorNodes = {}
    if(dataObject.identify === "tp"){
      var timePeriods = dataObject.data;
      for(let i = 0; i < timePeriods.length; i++){
        var start = "start-"+i;
        g.setNode("start-"+i, {shape: "circle", class : "start"});
        g.setNode("end-"+i, {shape: "circle", style: "stroke-width: 4; stroke: black"});
        obj = seqPreservingComparison(timePeriods[i], timePeriods[i].length, nodes, start, incomingXorNodes, "end-"+i)
        incomingXorNodes = obj.incomingXorNodes;
        endConnections.push(obj.endConection);
        nodes = obj.nodes;
      }
    }
    else{
      g.setNode("start-0", { shape: "circle" });
      g.setNode("end-0", {shape: "circle", style: "stroke-width: 4; stroke: black"})
      var length = clients[dataObject].length;
      var client = clients[dataObject];
      var start = "start-0"
      obj = seqPreservingComparison(client, length, nodes, start, incomingXorNodes, "end-0");
      incomingXorNodes = obj.incomingXorNodes;
      endConnections.push(obj.endConection);
      nodes = obj.nodes;
    }
    var endConection = obj.endConection;
    var totalRequestsData = totalNumberOfRequests(nodes);
    var totalRequests = totalRequestsData.total;
    var maxRequests = totalRequestsData.maxRequests;
    for(var key in nodes){
      var size = Object.keys(nodes[key]).length;
      if(size == 1){
        var status = Object.keys(nodes[key])[0]
        g.setNode(key+' '+status, { shape: "rect", label : nodes[key][status].statusArray[0].key + '\n' + status + '\n' + nodes[key][status].statusArray.length, class:"type-Request method-"+key+' '+status});
        if(nodes[key][status].outgoingXOR){
          g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
          var str = "inXOR-"+key
          g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
        else if((nodes[key][status].statusArray.length) > 1){
          var str = "inXOR-"+key
          g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
      }
      else{
        var st = Object.keys(nodes[key])[0]
        g.setNode(key, {shape: "rect", label: nodes[key][st].statusArray[0].key + '\n' + totalRequests[key], class: "type-Request method-"+key});
        g.setNode("middleXOR-"+key,{label: "XOR", shape: "diamond", class: "type-XOR"});
        var str = "inXOR-"+key
        g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        for(var status in nodes[key]){
          g.setNode(key+' '+status, {shape: "rect", label : status + '\n' + nodes[key][status].statusArray.length, class:"type-Response method-"+key+' '+status});
          if(nodes[key][status].outgoingXOR){
            g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
          }
        }
      }
    }
    //Compute Delay Avgs
    obj = computeMinMaxAvgDelayVal(nodes);
    nodes = obj.nodes;
    var totalAvgKey = obj.totalAvgKey;
    var maxDelay = obj.MAX;
    var minDelay = obj.MIN;
    // console.log(obj);
    //Set Up Edges
    for(var key in nodes){
      var str = "inXOR-"+key
      var size = Object.keys(nodes[key]).length
      var bin = computeAssignBin(totalAvgKey[key].totalDelayAvgKey, maxDelay, minDelay);
      if(size == 1){
        var status = Object.keys(nodes[key])[0]
        if(nodes[key][status].outgoingXOR){
          g.setEdge(key+' '+status,"XOR-"+key+' '+status,
          {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin});
          // g.setEdge("inXOR-"+key, key+' '+status, {label: "delayAvg: "+ delayAvg});
        }
        else{
          g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status,
          {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin})
        }
        if(nodes[key][status].statusArray.length > 1){
          g.setEdge("inXOR-"+key, key+' '+status,
          {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-"+bin})
          for(var space in incomingXorNodes[key]){
            var len = incomingXorNodes[key][space][0].length;
            if(len == 1){
              g.setEdge(incomingXorNodes[key][space][0][0], str,
                {class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-0"})
              }
              else{
                let avg = getIncomingEdgeIndexDelay(nodes, key, incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], incomingXorNodes[key][space].length);
                bin = computeAssignBin(avg, maxDelay, minDelay);
                g.setEdge(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], str,
                {class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-"+bin})
              }
            }
          }
        }
        else{
          var str1 = "middleXOR-"+key;
          // g.setEdge(str,key,{label: "Delay Average:"+delayAvg});
          g.setEdge(str,key, {
            class: "edge-thickness-"+totalRequests[key] + " " + "delay-coloring-"+bin});
            g.setEdge(key,str1, {class: "edge-thickness-"+totalRequests[key] + " " + "delay-coloring-0"});
            for(var status in nodes[key]){
              // console.log(nodes[key][status].avgDelay);
              bin = computeAssignBin(nodes[key][status].avgDelay, maxDelay, minDelay);
              g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%",
              class: "edge-thickness-" +nodes[key][status].statusArray.length + " " + "delay-coloring-"+bin})
              // g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%"+'\n'+"Delay Avg:" + (computeDelayAvg(nodes, key, status)/1000/60/60/24), labelType: "html"});
              if(nodes[key][status].outgoingXOR){
                g.setEdge(key+' '+status, "XOR-"+key+' '+status,
                {class: "edge-thickness-" + nodes[key][status].statusArray.length + " delay-coloring-0"});
              }
            }
            for(var space in incomingXorNodes[key]){
              var len = incomingXorNodes[key][space][0].length;
              if(len == 1){
                g.setEdge(incomingXorNodes[key][space][0][0], str,
                  {class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-0"})
                }
                else{
                  // console.log(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1]);
                  let avg = getIncomingEdgeIndexDelay(nodes, key, incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], incomingXorNodes[key][space].length);
                  // console.log(avg);
                  bin = computeAssignBin(avg, maxDelay, minDelay);
                  // console.log(bin);
                  g.setEdge(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], str,
                  {class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-"+bin})
                }
              }
            }
          }

          //Set Up End Node
          for(let i = 0; i < endConnections.length; i++){
            var endConection = endConnections[i];
            var spaces =  endConection.e1.split(' ');
            var k = spaces[0]
            var s = spaces[1]
            if(nodes[k][s].outgoingXOR){
              g.setEdge("XOR-"+k+' '+s, "end-"+i, {class: "edge-thickness-1 delay-coloring-0"})
            }
            else{
              g.setEdge(k+' '+s, "end-"+i, {class: "edge-thickness-1 delay-coloring-0"});
            }
          }
          g.nodes().forEach(function(v) {
            var node = g.node(v);
            // Round the corners of the nodes
            node.rx = node.ry = 5;
          });

          console.log(nodes);
          setNodeClasses(g, nodes, totalRequestsData);
          setVisualizationConfig(nfc, eft, edc, maxRequests);

          var svg = d3.select("svg");
          svg.selectAll("*").remove();
          var inner = svg.append("g");

          // Set up zoom support
          var zoom = d3.zoom().on("zoom", function() {
            inner.attr("transform", d3.event.transform);
          });
          svg.call(zoom);

          // Create the renderer
          var render = new dagreD3.render();
          // Run the renderer. This is what draws the final graph.
          render(inner, g);
          // Center the graph
          var initialScale = 0.2;
          svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));
          svg.selectAll("g.node.start").on("click", function(id) { var _node = g.node(id); console.log("Clicked " + id); });
        }
        //Get Delay Avg for Incoming Edge
        var getIncomingEdgeIndexDelay = function(nodes, k, node, counter){
          let avg = 0;
          let checker = 0;
          for(var s in nodes[k]){
            for(let i = 0; i < nodes[k][s].statusArray.length; i++){
              // console.log(nodes[k][s].statusArray[i]);
              if(nodes[k][s].statusArray[i].finalStart == node || 'XOR-'+nodes[k][s].statusArray[i].finalStart == node){
                // console.log(node);
                avg+=nodes[k][s].delayArray[i];
                checker++;
              }
            }
          }
          if(checker == counter) return (avg/counter);
          else {
            // console.log(nodes[k][s].statusArray);
            // console.log(node, checker, counter, k);
            console.log(counter);
            console.log("ERROR IN getIncomingEdgeIndexDelay")
          };
        }
        var setStyles = function(){
          for(let i = 0; i < 3; i++){
            let style = document.createElement('style')

            style.disabled = true;
            // WebKit hack :(
            style.appendChild(document.createTextNode(""));

            // Add the <style> element to the page
            document.head.appendChild(style);
            var x = document.getElementsByTagName("STYLE")[i];
            x.disabled = true;
          }
        }
        var setVisualizationConfig = function(nfc, eft, edc, maxRequests){
          var VisualizationConfig = document.getElementById("VisualizationConfig");
          var red = [255,0,0];
          var yellow = [255,255,0];
          setStyles();
          setNodeFrequencyColoring(red, yellow, "totalRequest", 1, maxRequests, document.getElementsByTagName("STYLE")[0].sheet);
          setEdgeFrequencyThickness("edge-thickness", 1, maxRequests, document.getElementsByTagName("STYLE")[1].sheet);
          setDelayFrequencyColoring(red, yellow, "delay-coloring", 0, 128, document.getElementsByTagName("STYLE")[2].sheet)
          setElementOnClick(nfc, 0);
          setElementOnClick(eft, 1);
          setElementOnClick(edc, 2);
          VisualizationConfig.style = "diplay: visible;"
        }
        var setElementOnClick = function(elem, index){
          elem.onclick = function(){
            if(elem.checked != true){
              var x = document.getElementsByTagName("STYLE")[index];
              x.disabled = true;
            }
            else{
              var x = document.getElementsByTagName("STYLE")[index];
              x.disabled = false;;
            }
          };
        }
        //Get Min & Max Delay Value of the whole Graph
        var computeMinMaxAvgDelayVal = function(nodes){
          var MAXtotal = Number.MIN_VALUE;
          var MINtotal = Number.MAX_VALUE;
          var avgStatus = 0;
          var avgTotal = 0;
          var counterStatus = 0;
          var counterTotal = 0;
          var totalAvgKey = {};
          for(var key in nodes){
            for(var status in nodes[key]){
              for(let i = 0; i < nodes[key][status].delayArray.length; i++){
                avgStatus+= nodes[key][status].delayArray[i];
                avgTotal += nodes[key][status].delayArray[i];
                counterStatus++;
                counterTotal++;
              }
              avgStatus = (avgStatus/counterStatus);
              nodes[key][status].avgDelay = avgStatus;
              if(MAXtotal < avgStatus) MAXtotal = avgStatus;
              if(MINtotal > avgStatus) MINtotal = avgStatus;
              avgStatus = 0;
              counterStatus = 0;
            }
            if(totalAvgKey[key] === undefined){
              totalAvgKey[key] = {};
              avgTotal = avgTotal/counterTotal;
              totalAvgKey[key].totalDelayAvgKey = avgTotal;
            }
            if(MAXtotal < avgTotal) MAXtotal = avgTotal;
            if(MINtotal > avgTotal) MINtotal = avgTotal;
            avgTotal = 0;
            counterTotal = 0;
          }
          return {
            nodes : nodes,
            totalAvgKey : totalAvgKey,
            MAX : MAXtotal,
            MIN : MINtotal,
          };
        }
        //Compute Bin and Assign it
        var computeAssignBin = function(val, max, min){
          var particle = (max - min)/128
          var bin = Math.round((val - min)/particle);
          return bin;
        }
        //Set Delay Classes
        // var setDelayClasses_old = function(first_color, second_color, class_prefix, minShading, maxShading){
        //   var style = document.createElement('style')
        //   style.appendChild(document.createTextNode(""));
        //   document.head.appendChild(style);
        //   var sheet = style.sheet;
        //   var MAX = maxShading;
        //   for(let i = minShading; i < maxShading; i++){
        //     var percent = calculatePercentage(minShading, MAX, i);
        //     var color = getGradientColor(first_color, second_color, percent);
        //     var fill = "fill: rgb("+color[0]+","+color[1]+","+color[2]+");";
        //     var stroke = "stroke: rgb("+color[0]+","+color[1]+","+color[2]+");";
        //     var strokeWidth = "stroke-width: 1.5px;";
        //     var clazz = "."+class_prefix+"-"+i;
        //     var st = stroke + '\n' + fill + '\n' + strokeWidth;
        //     sheet.insertRule(clazz+" { "+st+" }");
        //   }
        //   return style;
        // }

        var setFxClasses = function(class_prefix, minShading, maxShading, fx, sheet){
          var MAX = maxShading;
          for(let i = minShading; i <= maxShading; i++){
            var percent = calculatePercentage(minShading, MAX, i);

            var st = fx(percent, i);

            var clazz = "."+class_prefix+"-"+i;

            sheet.insertRule(clazz+" { "+st+" }");
          }
        }

        var setDelayFrequencyColoring = function(first_color, second_color, class_prefix, minShading, maxShading, sheet){

          var fx = function(percent, lvl){

            var color = getGradientColor(first_color, second_color, percent);
            var fill = "fill: rgb("+color[0]+","+color[1]+","+color[2]+");";
            var stroke = "stroke: rgb("+color[0]+","+color[1]+","+color[2]+");";
            var strokeWidth = "stroke-width: 1.5px;";
            return (stroke + '\n' + fill + '\n' + strokeWidth);

          };

          setFxClasses(class_prefix, minShading, maxShading, fx, sheet)

        }
        var setNodeFrequencyColoring = function(first_color, second_color, class_prefix, minShading, maxShading, sheet){
          var fx = function(percent, lvl){
            var color = getGradientColor(first_color, second_color, percent);
            var st = "fill: rgb("+color[0]+","+color[1]+","+color[2]+")";
            return st;
          }
          setFxClasses(class_prefix, minShading, maxShading, fx, sheet);
        }
        // Edge Frequency Thickness
        var setEdgeFrequencyThickness = function(class_prefix, minShading, maxShading, sheet){
          var fx = function(percent, lvl){
            var w = 3;
            var particle = w/maxShading;
            lvl--;
            w = 1.5 + lvl*particle;
            var st = "stroke: #333; fill: black; stroke-width: "+ w +"px;";
            return st;
          }
          setFxClasses(class_prefix, minShading, maxShading, fx, sheet);
        }
        var deleteStyles = function(){
          var x = document.getElementsByTagName("STYLE");
          for(let i = 0; i < x.length; i++){
            x[i].remove();
          }
        }

        //Disable Coloring, Set Media to Print
        var getGradientColor = function(color1, color2, weight){
          var w1 = weight;
          var w2 = 1 - w1;
          var rgb = [Math.round(color1[0] * w1 + color2[0] * w2),
          Math.round(color1[1] * w1 + color2[1] * w2),
          Math.round(color1[2] * w1 + color2[2] * w2)];
          return rgb;
        }
        var calculatePercentage = function(min, max, val){
          if((max-min) == 0) return 1;
          return (((val - min)) / (max - min))
        }
        //Set Classes of Nodes, corresponding with their number of requests.
        var setNodeClasses = function(g, nodes, totalRequestsData){
          var totalRequests = totalRequestsData.total;
          var maxRequests = totalRequestsData.maxRequests;
          var red = [255,0,0];
          var yellow = [255,255,0];
          for(var key in g._nodes){
            if(g._nodes[key].shape == "rect"){
              var spaces = key.split(' ');
              if(spaces[1] === undefined){
                // var percent = calculatePercentage(1, maxRequests, totalRequests[key]);
                // var color = getGradientColor(red, yellow, (percent));
                // g._nodes[key].style = "fill: rgb("+color[0]+","+color[1]+","+color[2]+")"
                g._nodes[key].class += " totalRequest-"+totalRequests[key];
              }
              else{
                // var percent = calculatePercentage(1, maxRequests, nodes[spaces[0]][spaces[1]].statusArray.length);
                // var color = getGradientColor(red, yellow, (percent));
                // g._nodes[key].style = "fill: rgb("+color[0]+","+color[1]+","+color[2]+")"
                g._nodes[key].class += " totalRequest-"+nodes[spaces[0]][spaces[1]].statusArray.length;
              }
            }
          }
        }
        var roundUp = function(num, precision){
          precision = Math.pow(10, precision)
          return Math.ceil(num * precision) / precision
        }
        var computeDelayAvg = function(nodes, key, st){
          var avg = 0;
          var counter = 0;
          if(st == "total"){
            let counter = 0;
            for(var status in nodes[key]){
              for(let i = 0; i < nodes[key][status].delayArray.length; i++){
                avg += nodes[key][status].delayArray[i];
                counter++;
              }
            }
            return (avg/counter);
          }
          for(let i = 0; i < nodes[key][st].delayArray.length; i++){
            avg += nodes[key][st].delayArray[i];
          }
          return (avg/nodes[key][st].delayArray.length);
        }
        </script>
        </html>
