<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dagre Interactive Demo</title>

  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
  <script src="/Users/ilijagjorgjiev/node_modules/dagre-d3/dist/dagre-d3.js"></script>
  <script src="data.js"></script>
  <!-- <script type="text/javascript" src="setup.js"></script> -->
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div>
    <div class="dropdown" style="float: left">
      <button class="dropbtn" onmouseover="displayClients()">Dropdown</button>
    </div>
    <svg> </g></svg>
  </div>
</body>
<script>
// Input related code goes here

// Create the dropdown-list of Clients.
var displayClients = function(){
  var div = document.getElementsByClassName("dropdown");
  var str = '<div class="dropdown-content"> '
  for(var client in clients){
    str+=('<a onclick="drawGraph(\''+client +'\')"> '+ client + '</a> ')
  }
  str+=('</div>')
  div[0].innerHTML += str;
}

//Draw the Graph for the selected IP.
var drawGraph = function(clientIP){
  var g = new dagreD3.graphlib.Graph()
  .setGraph({})
  .setDefaultEdgeLabel(function() { return {}; });

  // Here we"re setting nodeclass, which is used by our custom drawNodes function
  // below.
  g.setNode("start", { shape: "circle" });
  g.setNode("end", {shape: "circle", style: "stroke-width: 4; stroke: black"})

  // Set up edges, no special attributes.
  var seqArray= seqPreservingComparison(clients, clientIP);
  var client = clients[clientIP];
  var counter = 0;
  // console.log(seqArray)
  for(var key in seqArray){
    var size = Object.keys(seqArray[key]).length;
    if(size == 1){
      var status = Object.keys(seqArray[key])[0]
      if(seqArray[key][status][0].xor != undefined){
        // console.log(seqArray[key][status])
        g.setNode(seqArray[key][status][0].xor, {label: "XOR", shape: "diamond", class: "type-XOR"});
        counter++;
        g.setNode(seqArray[key][status][0].end,
          {label: "Method: "+ seqArray[key][status][0].data.method + '\n' + 'Status: '+ seqArray[key][status][0].data.status + '\n' +"Location:"+seqArray[key][status][0].data.location + '\n' + "Time: "+ seqArray[key][status][0].data.datetime,
          class: "type-Request method-"  + seqArray[key][status][0].data.method})
          g.setEdge(seqArray[key][status][0].start, seqArray[key][status][0].end);
          g.setEdge(seqArray[key][status][0].end, seqArray[key][status][0].xor);
        }
        else{
          g.setNode(seqArray[key][status][0].end,
            {label: "Method: "+ seqArray[key][status][0].data.method + '\n' + 'Status: '+ seqArray[key][status][0].data.status + '\n' +"Location:"+seqArray[key][status][0].data.location + '\n' + "Time: "+ seqArray[key][status][0].data.datetime,
            class: "type-Request method-"  + seqArray[key][status][0].data.method})
          g.setEdge(seqArray[key][status][0].start, seqArray[key][status][0].end)
          }
        }
        else{
          var status = Object.keys(seqArray[key])[0]
          g.setNode(key, {label: "Method: "+ seqArray[key][status][0].data.method + '\n' +"Location: "+ seqArray[key][status][0].data.location + '\n' + "Time: "+ seqArray[key][status][0].data.datetime, class: "type-Request method-"  + seqArray[key][status][0].data.method})
          for(var st in seqArray[key]){
            g.setNode(seqArray[key][st][0].end, {label : 'Status: ' + seqArray[key][st][0].data.status, class: "type-Response"})
            var keyD = key+"-D"
            g.setNode(keyD, {label: "XOR", shape: "diamond", class: "type-XOR"})
            g.setEdge(key,keyD)
            g.setEdge(keyD, seqArray[key][st][0].end)
            if(seqArray[key][st][0].xor !== undefined){
              console.log(seqArray[key][st][0].xor)
              g.setNode(seqArray[key][st][0].xor, {label: "XOR", shape: "diamond", class: "type-XOR"})
              counter++;
              g.setEdge(seqArray[key][st][0].end, seqArray[key][st][0].xor);
            }
            for(let i = 0; i < seqArray[key][st].length; i++){
              g.setEdge(seqArray[key][st][i].start, key)
            }
          }
        }
      }
      console.log(g.nodes())
      g.nodes().forEach(function(v) {
        var node = g.node(v);
        // Round the corners of the nodes
        node.rx = node.ry = 5;
      });

      // Set up an SVG group so that we can translate the final graph.

      var svg = d3.select("svg");
      svg.selectAll("*").remove();
      var inner = svg.append("g");

      // Set up zoom support
      var zoom = d3.zoom().on("zoom", function() {
        inner.attr("transform", d3.event.transform);
      });
      svg.call(zoom);

      // Create the renderer
      var render = new dagreD3.render();

      // Run the renderer. This is what draws the final graph.
      render(inner, g);

      // Center the graph
      var initialScale = 0.2;
      svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));

      svg.attr('height', g.graph().height * initialScale + 40);
    }

    //Simple Comparison Algorithm
    var simpleComparison = function(clients, clientIP){
      var size = clients[clientIP].length
      var responses = [];
      var marked = new Array(size).fill(false);
      for(let i = 0; i < size; i++){
        responses[i] = [];
        if(!marked[i]){
          responses[i].push({id : i, client : clients[clientIP][i]})
          marked[i] = true;
          for(let j = i+1; j < size; j++){
            if((clients[clientIP][j].status != responses[i][0].client.status) && (clients[clientIP][j].method == responses[i][0].client.method) &&
            clients[clientIP][j].location == responses[i][0].client.location){
              marked[j] = true;
              responses[i].push({id : j, client : clients[clientIP][j] })
            }
          }
        }
      }
      return responses;
    }
    //Sequence Preserving Comparison
    var seqPreservingComparison = function(clients, clientIP){
      var length = clients[clientIP].length
      var client = clients[clientIP];
      var counterArray = [];
      var prev = "start";
      var seqArray = []
      for(let i = 0; i < length; i++){
        var str = client[i].method + client[i].location
        var status = client[i].status;
        if(seqArray[str] === undefined){
          seqArray[str] = {}
        }
        var obj = {
          "start" : prev,
          "end" : i,
          "data" : client[i]
        }
        if(i == length-1) {obj.end = "end"}
        if(seqArray[str][status] === undefined){
          seqArray[str][status] = []
          prev = i;
        }
        else{
          obj.end = seqArray[str][status][0].end
          prev = seqArray[str][status][0].end
        }
        seqArray[str][status].push(obj)
      }
      var counter = 0;
      for(var key in seqArray){
        for(var status in seqArray[key]){
          if(seqArray[key][status].length > 1){
            counterArray.push(seqArray[key][status][0].end)
            for(let i = 0; i < seqArray[key][status].length; i++){
              seqArray[key][status][i].xor = "XOR-" + seqArray[key][status][i].end
            }
          }
        }
      }
      for(var key in seqArray){
        for(var status in seqArray[key]){
          for(let i = 0; i < seqArray[key][status].length; i++){
            for(let j = 0; j < counterArray.length; j++){
              if(seqArray[key][status][i].start == counterArray[j]){
                seqArray[key][status][i].start = "XOR-" + counterArray[j];
              }
            }
          }
        }
      }
      return seqArray;
    }
    </script>
    </html>
